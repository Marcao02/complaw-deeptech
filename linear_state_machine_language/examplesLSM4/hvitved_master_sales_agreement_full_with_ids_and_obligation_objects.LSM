(LSMVersion 4.0.0)

; *I should have said this earlier:*
; The LSM3 examples all have the following property 
; (which requires some easy automated theorem proving to verify) 
; which makes the conception of obligations and permissions extremely simple
; (and, I would argue, basically impossible to misuse):

; At any instant in contract execution:
; - There can be any number of permitted (“may”) actions by any number of 
; agents.
; - There can be at most one required (“must”) action. In particular, 
; its not possible to be in a contract state where two “must” rules are 
; active for one agent, or where two agents each have an active  “must” rule.

; In short, in LSM3 “must” means “must as the next action in this contract 
; execution”, and “may” means “may as the next action in this contract 
; execution”.


; ABOUT THIS EXAMPLE
; I think this is the ONLY example, out of all the Hvitved examples, SAFE, and
; monster burger, where it is advisable to have "first class" Obligation 
; objects in the state of the contract. Compare this to 
; ../examplesLSM3/hvitved_master_sales_agreement_full_with_ids.LSM
; which instead took the approach of using data structures and a new data type
; to track obligations. The difference (LSM3 version vs this version) is 
; analogous to introducing a combinator datatype vs using a language's 
; build-in function type.
;
; This takes us toward the idea of offering high level abstractions, 
; but with unusually-specific instructions on when to use them.
; I think we will want to retain finite-state LSM as a named 
; sublanguage of a more advanced version of  LSM that offers explicit 
; obligation objects (as I’ve demoed in this file). And we may want 
; to advise that the extra features of this more advanced language 
; only be used when infinite state is needed.
;
; I never liked having to introduce unbounded collection data structures 
; into LSM, because it would result in generated natural language contracts 
; that don’t read the way current natural language contracts do. This is 
; under the assumption that current natural language contracts rarely use 
; (informal) collection data structures. 


(ContractParams 
	(MAX_UNITS : ℕ := 1000)
	(CONTRACT_LIFE : Date := 1Y)
	(PRICE_PER_UNIT : $ := 100)
)

(GlobalVars 	
	( inconly next_order_id : Id := 0 )
	( inconly units_ordered : ℕ := 0 )	
	( writeonce contract_ends : Date )		
	( reactive orderable_units : ℕ := (MAX_UNITS - units_ordered))
	
	; `nonoperative` instructs our static checker to verify that these 
	; variables cannot affect program execution. They would only be used 
	; for verification conditions (which we haven't done in this example
	; yet).
	( nonoperative inconly units_delivered : ℕ := 0 )
	( nonoperative inconly total_paid : $ := 0 )
)

(Actors Customer Vendor)

(ProseContract 
	(P1 'The master agreement between Vendor and Customer is for {MAX_UNITS} printers, with a unit price of {PRICE_PER_UNIT}. The agreement is valid for {CONTRACT_LIFE}, starting 2011-01-01.')
	(P2 'The customer may at any time order an amount of printers (with the total not exceeding the threshold of {MAX_UNITS}), after which the Vendor must deliver the goods before the maximum of (i) 14 days, or (ii) the number of ordered goods divided by ten days.')
	(P3 'After delivering the goods, Vendor may bill the Customer within 1 month, after which the goods must be paid for by Customer within 14 days.')	
)

; NTS: removed preliminary work with VerificationDefinition, FOLContract, Conjecture

(FormalContract	
	"Master Sales Agreement"	
	(StartState Start)
	
	(Event&State Start()
		(Entrance
			(contract_ends = ((contract_start_date) + 1Y))
		)
		(Fallbacks
			(ContractLive())
		)			
	)

	(Event&State ContractLive()
		(ActorEvents
			(if (orderable_units > 0)
				(Customer may next and (by contract_ends) 
					do (SubmitNewOrder q) 
					for some (q : ℕ) such that (0 < q ≤ orderable_units))
			) 			
		)
		(Fallbacks
			; this will only be executed when 
			;	(a). the `if` condition in ActorEvents is false, or
			;	(b). orderable_units == 0			
			(Fulfilled())
		)
	)

	(Action (SubmitNewOrder (quantity : ℕ))
		(Entrance			
			; 14 days later, or quantity/10 days later, whichever occurs last
			(local delivery_deadline : Date = (dateplus 
				(event_start_date) 
				(days (max 14 (ceil (quantity / 10))))) )
			(units_ordered += quantity)
						
			( Vendor must later and (by delivery_deadline)
				do (Deliver quantity next_order_id) )
			(next_order_id += 1)
		)								
	)

	(Action (Deliver (quantity : ℕ) (orderid : ℕ))
		(Entrance
			( units_delivered += quantity )
			( Vendor may later and (by ((event_start_date) + 30D)) 
				do (SendInvoice quantity orderid) )
		)		
	)

	(Action (SendInvoice (quantity : ℕ) (orderid : ℕ))
		(Entrance						
			( units_invoiced += quantity ) 
			( Buyer must later (by ((event_start_date) + 14D)) 
				do (PayBill quantity orderid) )
		)
	)

	(Action (PayBill (quantity : ℕ) (orderid : ℕ))
		(Entrance
			( total_paid += (quantity * PRICE_PER_UNIT) )			
		)		
	)	
)

(DotFileName 'hvitved_master_sales_agreement_full_with_ids_and_obligation_objects.dot')
(ImgFileName 'hvitved_master_sales_agreement_full_with_ids_and_obligation_objects.png')