(LSMVersion 4.0.0)

; *I should have said this earlier:*
; The LSM3 examples all have the following property 
; (which requires some easy automated theorem proving to verify) 
; which makes the conception of obligations and permissions extremely simple
; (and, I would argue, basically impossible to misuse):

; At any instant in contract execution:
; - There can be any number of permitted (“may”) actions by any number of 
; agents.
; - There can be at most one required (“must”) action set (an action with 
; parameters, possibly constrained), belonging to one of the agents only, 
; such that the agent must do exactly one of the actions. 
;
; In LSM3 “must” means “must as the next action in this contract 
; execution”, and “may” means “may as the next action in this contract 
; execution”.
;
; This example introduces the feature of adding future obligations/permissions
; to the environment. This expands the characterization of the state of a 
; contract to the following (Γ is added):
; A tupple <t, σ, s, Γ> where
; - t is the current time
; - σ is an assignment of values to the global variables
; -	s is one of the fixed number of `State`s.
; - Γ is a finite set of fully-instantiated `Action`s (no parameters), each
;   of which is an obligation or a permission.

; ABOUT THIS EXAMPLE
; I think this is the ONLY example, out of all the Hvitved examples, SAFE, and
; monster burger, where it is advisable to have "first class" Obligation 
; objects in the state of the contract. Compare this to 
; ../examplesLSM3/hvitved_master_sales_agreement_full_with_ids.LSM
; which instead took the approach of using data structures and a new data type
; to track obligations. The difference (LSM3 version of example vs this version 
; of example) is very loosely analogous to introducing a combinator datatype 
; vs using a language's build-in function type.
;
; ASIDE:
;	This takes us toward the idea of offering high level abstractions, 
;	but with unusually-specific instructions on when to use them.
;	I think we will want to retain finite-state LSM as a named 
;	sublanguage of a more advanced version of LSM that offers explicit 
;	obligation objects (as I’ve demoed in this file). And we may want 
;	to advise that the extra features of this more advanced language 
;	_only_ be used when infinite state is needed.
;	I never liked having to introduce unbounded collection data structures 
;	into LSM (as in the LSM3 version of this example), 
;   because it would result in generated natural language contracts 
;	that don’t read the way current natural language contracts do (under 
;	the assumption that current natural language contracts rarely use 
;	(informal) collection data structures). 
;
;
; There's not much too it. We now have a minimal feature for adding obligations and permissions floating out in the future, whereas before the active obligations and permissions (can we say "deontics" or something like that?) were always specified by the current State.
; The main reason for this is that it will be better for NLG than using Set data structures


(ContractParams 
	(MAX_UNITS : ℕ := 1000)
	(CONTRACT_LIFE : Date := 1Y)
	(PRICE_PER_UNIT : $ := 100)
)

(GlobalVars 	
	( inconly next_order_id : Id = 0 )
	( inconly units_ordered : ℕ = 0 )	
	( writeonce contract_ends : Date )		
	( reactive orderable_units : ℕ = (MAX_UNITS - units_ordered))
	
	; `nonoperative` instructs our static checker to verify that these 
	; variables cannot affect program execution. They would only be used 
	; for verification conditions (which we haven't done in this example
	; yet).
	( nonoperative inconly units_delivered : ℕ = 0 )
	( nonoperative inconly total_paid : $ = 0 )
)

(Actors Customer Vendor)

(ProseContract 
	(P1 'The master agreement between Vendor and Customer is for {MAX_UNITS} printers, with a unit price of {PRICE_PER_UNIT}. The agreement is valid for {CONTRACT_LIFE}, starting 2011-01-01.')
	(P2 'The customer may at any time order an amount of printers (with the total not exceeding the threshold of {MAX_UNITS}), after which the Vendor must deliver the goods before the maximum of (i) 14 days, or (ii) the number of ordered goods divided by ten days.')
	(P3 'After delivering the goods, Vendor may bill the Customer within 1 month, after which the goods must be paid for by Customer within 14 days.')	
)

; NTS: removed preliminary work with VerificationDefinition, FOLContract, Conjecture

(FormalContract	
	"Master Sales Agreement"	
	(StartState Start)
	
	(Event&State (Start)
		(Entrance
			(contract_ends = ((contract_start_date) + 1Y))
		)
		(Fallback
			(VendorAcceptingOrders)
		)			
	)

	(Event&State (VendorAcceptingOrders)
		(ActorEvents
			(if (orderable_units > 0)
				(Customer may next and (by contract_ends) 
					do (SubmitNewOrder q) 
					for some (q : ℕ) such that (0 < q ≤ orderable_units))
			) 			
		)
		(Fallback
			; this will only be executed 
			;[ (a). the `if` condition in `ActorEvents` is false, i.e. `orderable_units` == 0, or
			;  (b). the time has passed `contract_ends` ]
			; AND there are no ‘floating’ obligations or permissions
			; in other words, when no actor can do anything
			(Fulfilled)
		)
	)
	(nlg VendorAcceptingOrders event "{Vendor} begins or continues accepting orders.")
	(nlg VendorAcceptingOrders state "{Vendor} is accepting orders.")

	(Action (SubmitNewOrder (quantity : ℕ))
		(Entrance			
			; 14 days later, or quantity/10 days later, whichever occurs last
			(local delivery_deadline : Date = (dateplus 
				(event_start_date) 
				(days (max 14 (ceil (quantity / 10))))) )
			(units_ordered += quantity)
						
			( Vendor must later and (by delivery_deadline)
				do (Deliver quantity next_order_id) )
			(next_order_id += 1)
		)								
	)

	(Action (Deliver (quantity : ℕ) (orderid : ℕ))
		(Entrance
			( units_delivered += quantity )
			( Vendor may later and (by ((event_start_date) + 30D)) 
				do (SendInvoice quantity orderid) )
		)		
	)

	(Action (SendInvoice (quantity : ℕ) (orderid : ℕ))
		(Entrance						
			( units_invoiced += quantity ) 
			( Buyer must later and (by ((event_start_date) + 14D)) 
				do (PayBill quantity orderid) )
		)
	)

	(Action (PayBill (quantity : ℕ) (orderid : ℕ))
		(Entrance
			( total_paid += (quantity * PRICE_PER_UNIT) )			
		)		
	)	
)

(DotFileName 'hvitved_master_sales_agreement_full_with_ids_and_obligation_objects.dot')
(ImgFileName 'hvitved_master_sales_agreement_full_with_ids_and_obligation_objects.png')