%useTabs
%!TEX useTabs
\documentclass[12pt]{article}
% Organization note: LegaleseResearchReportApril2018_packages.sty is _mostly_ package imports, but also contains some document-level usages of those packages.
\usepackage{LegaleseResearchReportApril2018_packages}
\usepackage{LegaleseResearchReportApril2018_environments}
\usepackage{LegaleseResearchReportApril2018_generic_macros}

\usepackage{draftwatermark}
\SetWatermarkText{DRAFT}
\SetWatermarkAngle{360}
\SetWatermarkVerCenter{80pt}
\SetWatermarkScale{2}
\SetWatermarkLightness{.85}

\newcommand{\minil}{\textsf{MiniL4}}

\newcommand{\term}[1]{\EM{\textsf{\hyperref[#1]{#1}}}\xspace}
\newcommand{\termz}[2]{\EM{\textsf{\hyperref[#1]{#2}}}\xspace}

\newcommand{\lasm}{\term{LASM}}
\newcommand{\lasms}{{\sf \hyperref[LASM]{LASMs}}\xspace}

\newcommand{\actor}{\term{actor}}
\newcommand{\codeactor}{\termz{codeactor}{Code}}

\newcommand{\timeunit}{\term{timeunit}}
\newcommand{\timestamp}{\term{timestamp}}
\newcommand{\timestamps}{\termz{timestamp}{timestamps}}

\newcommand{\statevars}{\term{statevars}}
%\newcommand{\statevartypes}{\termz{statevartypes}{statevar-domains}}
\newcommand{\statevartypes}{\termz{statevartypes}{VDom}}
\newcommand{\initvals}{\term{initvals}}

\newcommand{\ename}{\termz{ename}{event}}
\newcommand{\einst}{\termz{einst}{event-instance}}
\newcommand{\einsts}{\termz{einst}{event-instances}}

%\newcommand{\eparamtypes}[1]{\textsf{\hyperref[eparamtypes]{param-types}}_{#1}}
\newcommand{\eparamtypes}[1]{\textsf{\hyperref[eparamtypes]{Dom}}_{#1}}
\newcommand{\erule}{\termz{erule}{event-rule}}
\newcommand{\erules}{\termz{erule}{event-rules}}
\newcommand{\enabled}{\term{enabled}}
\newcommand{\compatible}{\term{compatible}}
\newcommand{\compatiblewith}{\termz{compatiblewith}{compatible with}}
\newcommand{\enabledguard}{\termz{enabledguard}{enabled-guard}}
\newcommand{\enabledguards}{\termz{enabledguard}{enabled-guards}}
\newcommand{\params}[1]{{\sf \hyperref[params]{params}}_{#1}} %for deadline event rules
\newcommand{\paramspart}[2]{{\sf \hyperref[paramspart]{params}}_{#1}^{#2}}
% re for 'rule enabled'
\newcommand{\reguard}[1]{\EM{\textsf{\hyperref[reguard]{enabled-guard}}_{#1}}}
\newcommand{\deadfn}[1]{\EM{\textsf{\hyperref[deadfn]{deadline}}_{#1}}}
% ep for 'event parameters'
\newcommand{\epconstr}[1]{\EM{\textsf{\hyperref[epconstr]{param-constraint}}_{#1}}}
\newcommand{\udc}{\termz{udc}{unambiguous default condition}}

\newcommand{\sname}{\termz{sname}{situation}}
\newcommand{\startsname}{\termz{startsname}{start-situation}}
\newcommand{\fulfilled}{\term{fulfilled}}
\newcommand{\breached}[1]{\EM{\textsf{\hyperref[breached]{breached}}_{#1}}\xspace}

\newcommand{\statetransform}[1]{\EM{\textsf{\hyperref[statetransform]{statetransform}}_{#1}}}
\newcommand{\statetransforms}{\EM{\textsf{\hyperref[statetransform]{statetransforms}}}}
\newcommand{\stranspart}[2]{\EM{\textsf{\hyperref[statetransform]{statetransform}}_{#1}^{#2}}}


\newcommand{\state}{\term{state}}
\newcommand{\statespace}{\termz{statespace}{state space}}

\newcommand{\shandler}{\termz{shandler}{situation-handler}}
\newcommand{\ehandler}{\termz{ehandler}{event-handler}}

\newcommand{\trace}{\term{trace}}
\newcommand{\wfeseq}{\termz{wfeseq}{well-formed event sequence}}

\newcommand{\Bool}{\textsf{bool}}
\newcommand{\DT}{\EM{\mathbb{\hyperref[DT]{D}}}\xspace}
\newcommand{\TS}{\EM{\mathbb{\hyperref[TS]{T}}}\xsapce}
\newcommand{\cF}{\EM{\mathcal{F}}\xspace}

%\author{Dustin Wehr\footnote{dustin.wehr@gmail.com}}
%\author{dustin.wehr@gmail.com}

\title{Legal Abstract State Machines, \\
L4, and Formal Verification of Contracts \\
\smaller \smaller Report on Computational Law Research by \extlink{https://legalese.com}{Legalese}\footnote{Contact: dustin.wehr@gmail.com or collective@legalese.com}\larger \larger }
\begin{document}
\maketitle

\begin{abstract}
This report is intended for industry and academics in Computational Law. However, by publication time it should be readable by anyone with an undergraduate level background in computer science or mathematics. We recommend joining \extlink{https://legalese.slack.com/messages/C0SB9HZ1S/}{the \#dsl channel} on \extlink{https://legalese.slack.com}{our Slack workspace}\footnote{https://legalese.slack.com} and introducing yourself if you're planning on spending more than half and hour with this document. %before delving into this. Most of the L4 documentation needs updating/improving, including this document, and Dustin or Meng will be much more motivated to prioritize that if they know there are people waiting for it.

The primary focus of this report is the definition of the programming language-independent mathematical model for computational legal contracts that we've settled on after a comprehensive review of the literature and many months of research. The model, tentatively called \textit{Legal Abstract State Machines} (\lasms), provides the formal semantics for our prototype open source computational legal contracts DSL L4, but it is intended to be a \textit{necessary substructure of the semantics of any computational legal contracts language that is worth a damn} (and we eagerly invite disputes).\footnote{L4's typesystem (Section \ref{typechecking}), though we are quite proud of it, is an example of a feature that does not meet this high standard. It is plausible that the complication it introduces, when in the presence of other optional language features that L4 does not have,  makes its inclusion unjustified.
In fact, it would be hard to add L4's typesystem to the definition of \lasms, as \lasms do not even have a term language!} In programming language theory jargon, \lasms are a denotational semantics.
\end{abstract}

\pagebreak

\tableofcontents


%\section{Who this is for and how to read it}
\section{Introduction}

We expect the Computational Law community will develop a number of independent, open source, computational contract DSLs, to suit different tastes and focuses, but we hope that the bulk of the work done by the community will be effectively reusable, particularly in statute and contract libraries, formal verification, and visualization. For this reason, not only have we made our DSL L4 completely free and open source, we have also ensured that none of our work on formal verification of contracts depends strongly on L4 - only on the much simpler mathematical model of Legal Abstract State Machines that one can use L4 (or your own DSL!) to construct.

Sections \ref{basics} and \ref{lasmdef} define Legal Abstract State Machines. Section \ref{static} documents our progress on static analysis for \lasms.

Hovering over (resp. clicking on) most terms in \textsf{{sf font}} should show you a popup of (resp. take you to)  where the term is defined, where the term is styled like \defstyle{this}. This might not work in all PDF viewers.


\section{Time, Actors, and Events} \label{basics}
We will always be working with a fixed minimal \firstuse{timeunit}{timeunit}, which will be one of days, hours, minutes, seconds, etc. It is a parameter of Legal Abstract State Machines (\lasms), and should be set to the smallest unit of time that one writes constraints about, or does arithmetic with, in the text of the legal contract one is modelling.  A \firstuse{timestamp}{timestamp} is \text{just} a nonnegative real number\footnote{See a few paragraph below for why it is \RR\, and not \NN.} that we \textit{think of} as being in units timeunit, which marks the time since the designated start of the \lasm execution, which is always 0 by definition.
%Let $\TS$ denote the nonnegative reals when used for this purpose.
It is worth emphasizing that timestamps are distinct from both DateTimes (some standard for calendar dates with optional within-day times) and TimeDeltas (i.e. durations), both of which are important datatypes in DSLs such as L4. We have found that there is no advantage, and significant disadvantage (when it comes to formal verification), to having DateTimes or TimeDeltas in the mathematical model.

Fix a set \firstuse{$\DT$}{DT} of basic datatypes, or {\it sorts}, which includes at least \Bool. The \lasm-compliant languages we use will usually include $\timestamp$, $\ZZ$, and $\RR$ as well. These datatypes should be definable types of \href{http://smtlib.cs.uiowa.edu/language.shtml}{SMT-LIB}. It is important to note that SMT-LIB itself allows for rich datatypes, including recursive datatypes, but also that a computational contracts DSL such as L4 or Ergo can include types beyond those easily definable in SMT-LIB (see Section \ref{typechecking}).

Fix a finite set of symbols \firstuse{actor}{actor}, which includes:
\begin{PPI}
\item The parties to the contract.
\item Any ``oracles'' that send information to the contract from the environment.
\item The special symbol \firstuse{\codeactor}{codeactor}, for events that are initiated by the code of the contract.
\end{PPI}
Before publication of this document, we will likely replace the finite set of party-\actor{s} with a finite set of {\it roles}, and allow for an unbounded number of party-actors in each role; that seems to be necessary to model many blockchain smart contracts in a natural way.

Fix a finite set of symbols \firstuse{event}{ename}, and for each such $e$ a parameter type assignment $\eparamtypes{e} \in \DT^*$. Furthermore, partition \ename into three kinds of events:
\begin{PPI}
\item party-events, which are actions done by a party-to-the-contract,
\item oracle events, which provide information from the environment, and
\item deadline events, which are transitions mandated by the contract.
\end{PPI}
An \firstuse{event instance}{einst} is a tuple $\tup{e,a,t,\sigma}$ where $e$ is an \ename, $a$ is an \actor, $t$ is a \timestamp, and $\sigma \in \eparamtypes{e}$. The \actor for a deadline \ename is always \codeactor.
%\todo{Alternatively, that's only for party and oracle events. A deadline event only needs the first and fourth components.}

%The  include ``oracle'' or environmental actions ``performed'' by the special \Actor \introx{Env}{Env}. We also use the special \Actor \introx{ContractActor}{Contract} for the \Actor component of \devents.

Event instances are instantaneous,\footnote{We might relax this before publication, after discussion with others in the Computational Law community.} occurring at a particular \timestamp; a real world event with duration is modelled by two such instantaneous \einsts, for the start and end of the real world event. That convention is quite flexible; it easily allows modelling overlapping real-world events, for example. We will see in the next section that a sequence of \einsts that constitutes a valid execution of an \lasm requires strictly increasing time stamps. For example, if the \timeunit is days, then three real-world events that happen in some sequence on the second day would happen at \timestamps $1, 1 + \epsilon_1,  1 + \epsilon_1 + \epsilon_2$, for some $\epsilon_1,\epsilon_2 > 0$. When we need to model two real-world events as truly-simultaneous, we use one event instance to model their cooccurrence \todo{example}. 

For our intended domain of legal contracts, we are not aware of any cogent criticism of requiring instantaneous event instances with strictly increasing timestamps; and \emph{\textbf{we welcome attempts}}. An earlier version of the model, in fact, did not require that timestamps are {\it strictly} increasing, used discrete time, and had what we believe was a very satisfying\footnote{Or ``elegant'', as unscrupulous researchers put it.} justification. However, the justification requires at least another paragraph, and probably several more to adequately defend it. Meanwhile, it offered no advantages in examples, and had one clear disadvantage for formal verification, where the use of integer variables is costly for SMT solvers.\footnote{The best explanation we have for this is not simple. It starts with noting that real arithmetic is decidable (real closed fields), but even quantifier free integer arithmetic is undecidable (diophantine equations). This does not necessarily mean that simple uses of integer variables will be costly, but in practice, as of April 2018, it seems to, at least to us outsiders. We are not aware of any particularly-useful decidable restriction of quantifier free combined real/integer arithmetic, and the currently-implemented heuristics, at least in Z3, are easily fooled.}

\section{Legal Abstract State Machines} \label{lasmdef}

A Legal Abstract State Machine (\lasm) first of all fixes the definitions of the terms introduced in Section \ref{basics}: \DT, \timeunit, \actor, and \ename. It also includes a finite set of symbols \firstuse{situation}{sname} that must contain at least the symbols:
\begin{PPI}
\item \fulfilled
\item $\breached{X}$ for each nonempty subset $X$ of $\actor \backslash \{\codeactor\}$.\footnote{These are breaches and oracle errors analogous to undifferentiated unhandled exceptions in software. Some well-drafted computational contracts might avoid using them completely.}
%There is also an \etype \intro{$\breaches{X}$} for each such $X$, and $\intro{\breach{X}{t}}$ is defined as the \FSContract \Event $\tup{\breaches{X}, \Env, t}$
\end{PPI}
%, and partitions \ename into three subsets: party event names, oracle event names, and deadline event names.
An \lasm $M$ also has an ordered finite set of symbols \firstuse{\statevars}{statevars}, and an assignment \firstuse{\statevartypes}{statevartypes} of a datatype from $\DT$ to each. Since the \statevars are ordered, we can take \statevartypes to be an element of $\DT^*$. $M$ also includes an initial setting \initvals of its \statevars.

The \firstuse{state space}{statespace} of $M$ is the product set
\[ \sname \times \statevartypes \times \timestamp\] %(element of $\TS$).
and a \firstuse{\state}{state} is an element of the \statespace.

The remainder and bulk of the definition of an \lasm is a mapping from \sname to {\it situation handlers}, and a mapping from \ename to {\it event handlers}.
An \firstuse{\ehandler}{ehandler} for \ename $e$ consists of:
\begin{PPI}
\item a destination \sname.
\item a function \firstuse{\statetransform{e}}{statetransform} of type
\[\timestamp^2 \times \statevartypes \times \eparamtypes{e} \rarr \statevartypes\]
\end{PPI}
where the two \timestamp arguments provided to \statetransform{e} will always be the \timestamps of the previous and next \einsts.

A \firstuse{\shandler}{shandler} is a finite set of {\it event rules}, where an \firstuse{\erule}{erule} is one of three types: a {\it party rule}, {\it oracle rule}, or {\it deadline rule}. Every \erule governs the applicability of a unique \ename by a unique \actor.\footnote{In L4, we offer syntax for concisely expressing a set of such rules that apply to different elements of \ename and \actor.} Every \erule $r$ has a relation \firstuse{\reguard{r}}{reguard} on 
\[\timestamp \times \statevartypes\]
where the \timestamp argument is the \timestamp of the previous \einst. Frequently in our examples, \reguard{r} is just the trivial relation \textsf{true}. $r$ is \firstuse{\enabled}{enabled} upon entering its parent situation at the \timestamp $t$ of the previous \einst iff \reguard{r} is true when evaluated at $t$ and the current statevar assignment. 

A deadline event rule $r$ governing the applicability of a deadline \ename $e$ has an additional {\it deadline function} $\firstuse{\deadfn{r}}{deadfn}$ of type
\[ \timestamp \times \statevartypes \rarr \timestamp\]
where the \timestamp argument is the \timestamp of the previous \einst.
$r$ also has a {\it parameter setter} $\firstuse{\params{r}}{params}$ of type
\[ \timestamp^2 \times \statevartypes \rarr \eparamtypes{e}  \]
where the two \timestamp arguments are the \timestamps of the previous and next \einsts.

Since deadline \erules cause an event to occur automatically when the rule activates, we would need to either specify what happens when two such rules activate at the same time, or else ensure that can't happen. We take the latter approach.\footnote{Because we see no natural way to pick one over the other. Note that the \erules are not ordered.} For now, we adopt a constraint that is stronger than necessary but especially simple:\footnote{A closer-to-minimal constraint is: when the \enabledguards of two deadline \erules are simultaneously true, their deadline functions cannot yield the same \timestamp (and then the earlier of the two deadlines is used). We have not yet experienced any desire for the extra leniency, but in case we do, it would be easy to allow it.} \\
\noindent \firstuse{\udc}{udc}:  if a \sname has multiple \erules, their \enabledguards must be disjoint relations.



Each party and oracle event rule $r$ governing the applicability of a party or oracle \ename $e$ has an additional {\it parameter constraint relation} \firstuse{$\epconstr{r}$}{epconstr} on
\[ \timestamp^2 \times \statevartypes \times \eparamtypes{e}\]
where the two \timestamp arguments are the \timestamps of the previous and next \einsts.
Note that a {\it parameter setter} is a special case of a {\it parameter constraint relation}. Because that special case is used fairly frequently, in L4 we allow party and oracle event rules to use the {\it parameter setter} syntax of deadline event rules instead of their own {\it parameter constraint relation} syntax.
\begin{center}
That completes the definition of a Legal Abstract State Machine.
\end{center}

We now define the {\it well-formed event sequences} of an \lasm $M$, which are a superset of the {\it traces} of $M$ defined next.
\begin{defn}[\erule \firstuse{compatible with}{compatiblewith} \einst] 
An \erule $r$ is \compatiblewith an \einst $\tup{e, a, t, \sigma}$ iff $e$ and $a$ are the \ename and \actor that $r$ governs the applicability of. 
\end{defn}
\begin{defn}[\firstuse{well-formed event sequence}{wfeseq}]
Fix an \lasm $M$. \\ A \wfeseq of $M$ is a sequence of \einsts $E_0,E_1,\ldots$ with strictly-increasing \timestamps such that, if $\tup{e_i, a_i, t_i, \sigma_i}$ is $E_i$, then
\begin{LPPI}
\item The \startsname $s_0$ of $M$ has an \erule \compatiblewith $E_0$
\item Either the destination \sname $s_{i+1}$ of $e_i$ has an \erule \compatiblewith $E_{i+1}$, or else $E_i$ is the final element of the sequence and $s_i$ is \fulfilled or $\breached{X}$ for some $X \subseteq \actor$.
\end{LPPI}
\end{defn}

\bigskip

\larger\noindent{\bf Execution of \lasms}\smaller \\

Let $\tau = E_1, E_2, \dots$ be a (finite or infinite) \wfeseq of $M$. The starting \state $G_0$ is always $\tup{\startsname, 0, \initvals}$. Let $i \geq 0$ be arbitrary. Assume the sequence is a valid trace up to entering $G_i = \tup{s,t,\pi}$. Let $E_i$ be $\tup{e, a, t', \sigma}$. We now define the valid values of $G_{i+1} = \tup{s', t', \pi'}$:
\begin{PPI}

\item If $E_i$ is a party (resp. oracle) \ename, then it must be \compatiblewith some party (resp. oracle) \erule $r$ of $s$ that is \enabled in $G_i$ such that $\epconstr{r}$ is true at $\tup{t, t', \pi, \sigma}$.

\item If $E_i$ is a deadline \ename, then it must be \compatiblewith the unique\footnote{by the \udc} deadline \erule $r$ of $s$ that is enabled in $G_i$ such that $\deadfn{r}(t, \pi) = t'$.

\item $\pi' = \statetransform{e}(t, t', \pi, \sigma)$.

\end{PPI}
Any \wfeseq where $G_i, E_i$ satisfy the above requirements for all $i$ is a valid \trace for $M$.

\subsection{Reducing the Abstraction One Level}
So far, \lasm is not a complete language, in the sense that it does not have an abstract syntax tree. In particular, we specified that certain components are mathematical {\it functions} or {\it relations}, rather than expressions that define such functions or relations. To recap, those components are as follows, where now we adopt the common convention of writing the types of relations as functions to \Bool.
\smallskip

\noindent {\bf Initial abstract components of \lasm \label{initialabstract}}:
\begin{LPPI}
\item $\statetransform{e} : \timestamp^2 \times \statevartypes \times \eparamtypes{e} \rarr \statevartypes$ for each \ename $e$.
\item $\reguard{r} : \timestamp \times \statevartypes \rarr \Bool$ for each \erule $r$.
\item For each party or oracle \erule $r$ than governs an \ename $e$:
	\begin{LPPI} 
	\item $\epconstr{r} : \timestamp^2 \times \statevartypes \times \eparamtypes{e} \rarr \Bool$
	\end{LPPI}
\item For each deadline \erule $r$ than governs an \ename $e$.
	 \begin{LPPI}
	\item $\deadfn{r} : \timestamp \times \statevartypes \rarr \timestamp$
	\item $\params{r} : \timestamp^2 \times \statevartypes \rarr \eparamtypes{e}$ 	
	\end{LPPI}
\end{LPPI}

Despite the lack of concreteness, we saw that there is enough detail that execution can be defined precisely. We {\it could} stop there, but that would mean leaving out of the coming sections some useful details of formal verification routines that are very likely to be needed in any \lasm-compliant DSL. 

In this section, we reduce the {\it description} of the abstraction level quite dramatically, while maintaining the flexibility of being able to define \lasm-compliant languages that range from finite state machines to Turing complete languages (and, technically, \extlink{https://en.wikipedia.org/wiki/Turing_degree}{beyond Turing complete languages}, but we don't know of any practical uses of such languages!).

Recall that that the set of basic datatypes or {\it sorts} \DT is a parameter to \lasm. After this section, we will have a notion of \firstuse{\it class of \lasm}{lasmclass} that depends only on \DT and a set \cF of functions on the sorts in \DT; that is, each function in such a set \cF is of type $S_1 \times \cdots \times S_k \rarr S_0$ for some $S_0,\ldots,S_k \in \DT$.

Assume $\timestamp \in \DT$.\footnote{Technically this implies that an extra constraint will be needed to define finite-state machines: roughly, that no \statevars of type \timestamp are allowed, and the functions in \cF cannot depend on their \timestamp arguments, even if \timestamp appears in the function type.} Surprisingly little is needed in the way of additional definitions. Since $\statevartypes \in \DT^*$ already, the functions $\reguard{r}$, $\epconstr{r}$, and $\deadfn{r}$ are already of the required $\cF$-form. The remaining two categories of functions, $\params{r}$ and $\statetransform{e}$, in the bullet-list above simply get replaced by their components:

\begin{LPPI}
\item For each deadline \erule $r$ that governs an \ename $e$, and each sort $S_i \in \eparamtypes{e}$, a function $\paramspart{r}{i} :  \timestamp^2 \times \statevartypes \rarr S_i$
\item For each \ename $e$, and each sort $S_i \in \statevartypes$, a function $\stranspart{e}{i} : \timestamp^2 \times \statevartypes \times \eparamtypes{e} \rarr S_i$.
\end{LPPI}


\section{Formal Verification for \lasm} \label{lasmstatic}

\subsection{Satisfiability Modulo Theories (SMT) Technology}
%We use SMT solver tech extensively, but might help.
Familiarity with SMT is not a prerequisite for this document, but if you are unfamiliar and interested, Microsoft's \extlink{https://rise4fun.com/z3/tutorial}{Z3 tutorial} is a fine place to start.

\subsection{Symbolic Execution}
In model checking for expressive models (say, with at least nonlinear integer arithmetic available), usually\footnote{The term ``model checking'' is used rather inconsistently.} an infinite-state model is approximated by a finite or tamely-infinite state model, and correctness properties of the approximation model are checked exhaustively, or exhaustively up to a certain maximum computation path length. In Section \ref{tamelyinfinite} we will consider some cases where approximation is not necessary.

Symbolic execution is a technique for avoiding some of the approximation, especially for avoiding having to approximate unbounded datatypes with bounded ones (e.g. $\RR$ approximated by {\sf float}). We do not do this for the sake of more accurate/faithful correctness theorems. Indeed, most of the time software is executed with bounded numeric datatypes anyway, and even when not, no fixed computer can actually compute with arbitrarily large numbers. Rather, we use symbolic execution because, if there is not actually complex math going on (e.g. any cryptographic functions) in a program, but only the use of functions that puts us outside decidable theories, then we should be able to save a lot of time by analyzing computation paths in axiomatically-defined batches. 

\bigskip

When we symbolically execute an \lasm, we have a choice about whether to use some, all, or none of the machine's \initvals of its \statevars. Generally, the more of them used, the faster \statespace exploration will be. For example, in a loan agreement, we could treat an interest rate as an arbitrary element of $(0,1)$. We would then be proving correctness of the agreement for interests rates that we'll never use, which of course is perfectly fine if the analysis finishes in a reasonable amount of time. Alternatively, we could use fixed values of the interest rate only, and whenever we use a new fixed interest rate, we simply rerun symbolic execution.

%For simplicity, we will give here a symbolic execution algorithm without some simple optimizations that we have implemented. Most notably, we will introduce new constants whenever it's convenient to do so. 
%

\section{\minil\, - A Minimal \lasm-Compatible DSL} \label{minil4}


In Section \ref{lasmstatic}, we gave as much detail as we could about our formal verification progress for \lasms. To go further, we need a complete language, 



\section{Formal Verification for \minil} \label{minil4static}

\subsection{Symbolic Execution}


\subsection{Exhaustive Model Checking for finite or tamely-infinite state spaces} \label{tamelyinfinite}
Suppose the only \statevars in an \lasm $M$ are boolean, and suppose that for every \erule $r$ none of $\enabledguard{r}$, $\reguard{r}$, $\deadfn{r}$, or $\epconstr{r}$ depend on their \timestamp arguments. Then $M$ is equivalent for formal verification purposes to a kind of compressed\footnote{via the boolean \statevars} deterministic finite state machine (FSM). If there are no \statevars, then $M$ is equivalent for formal verification purposes to a normal FSM. Many important properties about FSMs are decidable. If the specification of such a model $M$ is given entirely in terms of a \statespace invariant, then full formal verification can be checked exhaustively by well-known methods.

We may relax the constraint on the functions/predicates that take \timestamp arguments somewhat, which results in a computation model similar to \\ \extlink{https://drum.lib.umd.edu/bitstream/handle/1903/15232/Fontana_umd_0117E_15027.pdf?sequence=1&isAllowed=y}{Timed Automata} with a single clock (but we have not yet mapped the correspondence carefully!).

\subsection{Unbounded-Trace Formal Verification with Pre/Postconditions and Invariants}

\subsection{Unexplored: Hard Unbounded-Trace Formal Verification with Interactive Theorem Proving}

\section{L4: Experimental-But-Practical \lasm DSL}

\subsection{Type Checking with Subtyping and Intersection Types} \label{typechecking}


\section{Related Work}

This is thoroughly covered by \extlink{https://github.com/legalese/legalese-compiler/blob/master/doc/chapter-201707.org}{Meng's book chapter} and Appendix B of the \extlink{https://conferences.law.stanford.edu/compkworking201709/wp-content/uploads/sites/40/2017/07/WhitePaperDraftfordistroApril32018.pdf}{CodeX whitepaper} {\it Developing a Legal Specification Protocol: Technological Considerations and Requirements.}



\end{document}
