%useTabs
%!TEX useTabs
\documentclass[12pt]{article}
% Organization note: LegaleseResearchReportApril2018_packages.sty is _mostly_ package imports, but also contains some document-level usages of those packages.
\usepackage{LegaleseResearchReportApril2018_packages}
\usepackage{LegaleseResearchReportApril2018_environments}
\usepackage{LegaleseResearchReportApril2018_generic_macros}




\newcommand{\lasm}{{\sf LASM}\xspace}
\newcommand{\lasms}{{\sf LASM}s\xspace}

\newcommand{\actor}{{\sf actor}\xspace}
\newcommand{\codeactor}{\EM{\textsf{Code}}\xspace}

\newcommand{\timeunit}{{\sf timeunit}\xspace}
\newcommand{\timestamp}{{\sf timestamp}\xspace}
\newcommand{\timestamps}{{\sf timestamps}\xspace}

\newcommand{\statevars}{\textsf{statevars}\xspace}
\newcommand{\statevartypes}{\textsf{statevar-domains}\xspace}
\newcommand{\initvals}{\textsf{initvals}\xspace}

\newcommand{\ename}{{\sf event}\xspace}
\newcommand{\einst}{{\sf event-instance}\xspace}
\newcommand{\einsts}{{\sf event-instances}\xspace}

\newcommand{\eparamtypes}[1]{\textsf{param-types}_{#1}}
\newcommand{\params}[1]{\textsf{params}_{#1}} % for deadline event rules

\newcommand{\erule}{\textsf{event-rule}\xspace}
\newcommand{\enabled}{\textsf{enabled}\xspace}
\newcommand{\compatible}{\textsf{compatible}\xspace}
\newcommand{\enabledguard}{{\sf enabled-guard}\xspace}
% re for 'rule enabled'
\newcommand{\reguard}[1]{\EM{\textsf{enabled-guard}_{#1}}}
\newcommand{\deadfn}[1]{\EM{\textsf{deadline}_{#1}}}
% ep for 'event parameters'
\newcommand{\epconstr}[1]{\EM{\textsf{param-constraint}_{#1}}}

\newcommand{\sname}{\textsf{situation}\xspace}
\newcommand{\startsname}{\textsf{start-situation}\xspace}
\newcommand{\fulfilled}{\textsf{fulfilled}\xspace}
\newcommand{\breached}[1]{\EM{\textsf{breached}_{#1}}\xspace}


\newcommand{\statetransform}[1]{\EM{\textsf{statetransform}_{#1}}}

\newcommand{\DT}{\EM{\mathbb{D}}}
\newcommand{\TS}{\EM{\mathbb{T}}}

\newcommand{\state}{\EM{\textsf{state}}\xspace}

\newcommand{\shandler}{\textsf{situation-handler}\xspace}
\newcommand{\ehandler}{\textsf{event-handler}\xspace}

\newcommand{\trace}{\EM{\textsf{trace}}\xspace}


\newcommand{\todo}[1]{({\color{red} todo: #1})}

\title{Legal Abstract State Machines, \\
L4, and Formal Verification of Contracts \\
\smaller \smaller Report on Computational Law Research \larger \larger }
\begin{document}
\maketitle

\begin{abstract}
This report is intended for industry and academics in Computational Law. It should, however, be readable by anyone with an undergraduate level background in computer science or mathematics. We recommend joining \href{https://legalese.slack.com/messages/C0SB9HZ1S/}{the \#dsl channel}\footnote{https://legalese.slack.com/messages/C0SB9HZ1S/} on \href{https://legalese.slack.com}{our Slack workspace}\footnote{https://legalese.slack.com} and introducing yourself if you're planning on spending more than a half hour with this document. %before delving into this. Most of the L4 documentation needs updating/improving, including this document, and Dustin or Meng will be much more motivated to prioritize that if they know there are people waiting for it.

The primary focus of this report is the definition of the programming language-independent mathematical model for legal contracts that we've settled on after a comprehensive review of the literature and many months of research. The model, tentatively called \textit{Legal Abstract State Machines} (\lasms), provides the formal semantics for our prototype open source computational legal contracts DSL L4, but it is intended to be a \textit{necessary substructure of the semantics of any computational legal contracts language that is worth a damn} (and we eagerly invite disputes). In programming language theory jargon, \lasms are a denotational semantics.
\end{abstract}

\pagebreak

\tableofcontents


%\section{Who this is for and how to read it}
\section{Introduction}

We expect the Computational Law community will develop a number of independent, open source, user-facing DSLs to suit different tastes and focuses, but we hope that the community will be able to share the bulk of our work, particularly in statute and contract libraries, formal verification, and visualization. For this reason, not only is Legalese's DSL L4 completely free and open source, but also none of Legalese's work on formal verification of contracts depends strongly on L4 - only on the much simpler mathematical \lasm models that one can use L4 (or your own DSL!) to construct.

Sections \ref{basics} and \ref{lasmdef} define Legal Abstract State Machines. Section \ref{static} documents our progress on static analysis for \lasms.

\section{Time, Actors, and Events} \label{basics}
We will always be working with a fixed minimal \defstyle{timeunit}, which will be one of days, hours, minutes, seconds, etc. It is a parameter of Legal Abstract State Machines (\lasms), and should be set to the smallest unit of time that one writes constraints about, or does arithmetic with, in the text of the legal contract one is modelling.  A \defstyle{timestamp} is \text{just} a nonnegative real number\footnote{See a few paragraph below for why it is \RR\, and not \NN.} that we \textit{think of} as being in units timeunit, which marks the time since the designated start of the \lasm execution, which is always 0 by definition.
%Let $\TS$ denote the nonnegative reals when used for this purpose.
It is worth emphasizing that timestamps are distinct from both DateTimes (some standard for calendar dates with optional within-day times) and TimeDeltas (i.e. durations), both of which are important datatypes in DSLs such as L4. We have found that there is no advantage, and significant disadvantage (when it comes to formal verification), to having DateTimes or TimeDeltas in the mathematical model.

Fix a set \defstyle{$\DT$} of basic datatypes, which includes at least Bool, $\ZZ$, and $\RR$. 
Fix a finite set of labels \defstyle{actor}, which includes: 
\begin{PPI}
\item The parties to the contract.
\item Any ``oracles'' that send information to the contract from the environment.
\item The special symbol \codeactor, for events that are initiated by the code of the contract.
\end{PPI} 
Before publication of this document, we will likely replace the finite set of party-actors with a finite set of {\it roles}, and allow for an unbounded number of party-actors in each role; that seems to be necessary to model many blockchain smart contracts in a natural way.

Fix a finite set of labels \defstyle{\ename}, and for each such $e$ a parameter type assignment $\eparamtypes{e} \in \DT^*$. Furthermore partition \ename into three kinds of events: 
\begin{PPI}
\item party-events, which are actions done by a party-to-the-contract,
\item oracle events, which provide information from the environment. 
\item deadline events, which are transitions mandated by the contract, and  
\end{PPI}
An \defstyle{\einst} is a tuple $\tup{e,a,t,\sigma}$ where $e$ is an \ename, $a$ is an \actor, $t$ is a \timestamp, and $\sigma \in \eparamtypes{e}$. The \actor for a deadline event always \codeactor.
%\todo{Alternatively, that's only for party and oracle events. A deadline event only needs the first and fourth components.}

%The  include ``oracle'' or environmental actions ``performed'' by the special \Actor \introx{Env}{Env}. We also use the special \Actor \introx{ContractActor}{Contract} for the \Actor component of \devents.

Event instances are instantaneous,\footnote{We may relax this before publication.} occurring at a particular \timestamp; a real world event with duration is modelled by two such instantaneous \einsts, for the start and end of the real world event. That convention is quite flexible; it easily allows modelling overlapping real-world events, for example. We will see that a sequence of \einsts that constitutes a valid execution of a contract requires strictly increasing time stamps. When we need to model two real-world events as truly-simultaneous, we use one event instance to model their cooccurrence \todo{example}. If the \timeunit is days, then three real-world events that happen in some sequence on the second day would happen at \timestamps $1, 1 + \epsilon_1,  1 + \epsilon_1 + \epsilon_2$, for some $\epsilon_1,\epsilon_2 > 0$.

For our intended domain of legal contracts, we are not aware of any cogent criticism of requiring instantaneous event instances with strictly increasing timestamps; and \emph{\textbf{we welcome attempts}}. An earlier version of the model, in fact, did not require that timestamps are strictly increasing, and used discrete time, with what we believe was a very satisfying\footnote{Or ``elegant'', as unscrupulous researchers put it.} justification. However, the justification requires at least another paragraph, and probably several more to adequately defend it. Meanwhile, it offered no advantages in examples, and had one clear disadvantage for formal verification, where the use of integer variables is costly for SMT solvers.\footnote{The best explanation we have for this is not simple. It starts with noting that real arithmetic is decidable (real closed fields), but even quantifier free integer arithmetic is undecidable (diophantine equations). This does not necessarily mean that simple uses of integer variables will be costly, but in practice, as of April 2018, it seems to, at least to us outsiders. We are not aware of any particularly-useful decidable restriction of quantifier free combined real/integer arithmetic, and the currently-implemented heuristics, at least in Z3, are easily fooled.}

\section{Legal Abstract State Machines} \label{lasmdef}

A Legal Abstract State Machine (\lasm) first of all fixes the definitions of the terms introduced in Section \ref{basics}: \timeunit, $\DT$, \actor, and \ename. It also includes an initial setting \initvals of its \statevars, and a finite set of labels named \defstyle{\sname} which must contain the symbols
\begin{PPI}
\item \fulfilled
\item $\breached{X}$ for each nonempty subset $X$ of \actor. %There is also an \etype \intro{$\breaches{X}$} for each such $X$, and $\intro{\breach{X}{t}}$ is defined as the \FSContract \Event $\tup{\breaches{X}, \Env, t}$
\end{PPI}
%, and partitions \ename into three subsets: party event names, oracle event names, and deadline event names.
An \lasm $M$ also has an ordered finite set of \defstyle{\statevars}, and an assignment \defstyle{\statevartypes} of a datatype from $\DT$ to each. Since the \statevars are ordered, we can take \statevartypes to be an element of $\DT^*$. The {\it state space} of $M$ is the product set 
\[ \sname \times \statevartypes \times \timestamp\] %(element of $\TS$). 
and a \defstyle{state} is an element of the state space.

The remainder and bulk of the definition of an \lasm, is a mapping from \sname to {\it situation handlers}, and a mapping from \ename to {\it event handlers}.
An \defstyle{event handler} for \ename $e$ consists of: 
\begin{PPI}
\item a destination \sname.
\item a function \defstyle{\statetransform{e}} of type 
\[\timestamp^2 \times \statevartypes \times \eparamtypes{e} \rightarrow \statevartypes\]
\end{PPI}

A \defstyle{\shandler} is a finite set of {\it event rules}, where an \defstyle{\erule} is one of three types: a {\it party rule}, {\it oracle rule}, or {\it deadline rule}. Every \erule $r$ has a relation \defstyle{\reguard{r}} on $\timestamp \times \statevartypes$, where the \timestamp argument is the \timestamp of the previous \einst. Frequently \reguard{r} is just  the trivial relation \textsf{true}. $r$ is \defstyle{\enabled} upon entering its parent situation at the \timestamp $t$ of the previous \einst iff \reguard{r} is true when evaluated at $t$ and the current statevar assignment. 

A deadline event rule $r$ governing the applicability of a deadline \ename $e$ has an additional {\it deadline function} $\defstyle{\deadfn{r}}$ of type 
\[ \timestamp \times \statevartypes \rightarrow \timestamp\]
where the \timestamp argument is the \timestamp of the previous \einst,
and a {\it parameter setter} $\defstyle{\params{r}}$ of type
\[ \timestamp^2 \times \statevartypes \rightarrow \eparamtypes{e}  \]
where the two \timestamp arguments are the \timestamps of the previous and next \einsts.

Each party and oracle event rule $r$ governing the applicability of a party or oracle \ename $e$ has an additional {\it parameter constraint relation} \defstyle{$\epconstr{r}$} on
\[ \timestamp^2 \times \statevartypes \times \eparamtypes{e}\]
where the two \timestamp arguments are the \timestamps of the previous and next \einsts.
Note that a {\it parameter setter} is a special case of a {\it parameter constraint relation}. Because that special case is used fairly frequently, in L4 we allow party and oracle event rules to use the {\it parameter setter} syntax of deadline event rules instead of their own {\it parameter constraint relation} syntax.
\begin{center}
That completes the definition of a Legal Abstract State Machine.
\end{center}

We now define the {\it well-formed event sequences} of an \lasm $M$, which are a superset of the {\it traces} of $M$ defined next.
\begin{defn}[\defstyle{well-formed event sequence}]
Fix an \lasm $M$. A well-formed event sequence of $M$ is a sequence of \einsts $E_0,E_1,\ldots$ with strictly-increasing \timestamps such that, if $\tup{e_i, a_i, t_i, \sigma_i}$ is $E_i$, then
\begin{LPPI}
\item The \startsname $s_0$ of $M$ has an \erule compatible with $E_0$
\item Either the destination \sname $s_{i+1}$ of $e_i$ has an \erule governing $e_{i+1}$ and $a_{i+1}$ , or $E_i$ is the final element of the sequence and $s_i$ is a {\it breach} or {\it fulfilled} \sname. 
\end{LPPI}
\end{defn}

\bigskip

\larger\noindent{\bf Execution of \lasms}\smaller \\

Let $\tau = E_1, E_2, \dots$ be a (finite or infinite) well-formed event sequence of $M$. The starting \state $G_0$ is always $\tup{\startsname, 0, \initvals}$. Let $i \geq 0$ be arbitrary. Assume the trace is valid up to entering $G_i = \tup{s,t,\pi}$. Let $E_i$ be $\tup{e, a, t', \sigma}$. We now define the valid values of $G_{i+1} = \tup{s', t', \pi'}$: 
\begin{PPI}

\item If $E_i$ is a party (resp. oracle) \ename, then it must be {\it compatible with} some party (resp. oracle) \erule $r$ of $s$ that is \enabled in $G_i$ such that $\epconstr{r}$ is true at $\tup{t, t', \pi, \sigma}$. 

\item If $E_i$ is a deadline \ename, then it must be \compatible with the unique deadline \erule $r$ of $s$ that is enabled in $G_i$ such that $\deadfn{r}(t, \pi) = t'$.\footnote{Unique by the \todo{udt}} 

\item $\pi' = \statetransform{e}(t, t', \pi, \sigma)$.

\item If $s'$ is $fulfilled$ or $breached_{X}$ for some $X \subseteq \actor$, then $E_i$ must be the final event in the \trace.
\end{PPI}
Any \ename sequence where $G_i, E_i$ satisfy the above requirements for all $i$ is valid \trace for $M$.

\section{Formal Verification of \lasms} \label{static}

\subsection{Satisfiability Modulo Theories (SMT) Technology}

\subsection{Type Checking with Subtyping and Intersection Types}

\subsection{Symbolic Execution}

\subsection{Full Formal Verification with Pre/Postconditions and Invariants}

\subsection{Unexplored: Full {\it Hard} Formal Verification with Interactive Theorem Proving}

\section{A Prototype Computational Contracts DSL: L4}

 

\end{document}
