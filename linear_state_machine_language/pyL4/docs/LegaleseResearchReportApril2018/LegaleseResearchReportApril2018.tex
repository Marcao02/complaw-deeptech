%useTabs
%!TEX useTabs
\documentclass[12pt]{article}
% Organization note: LegaleseResearchReportApril2018_packages.sty is _mostly_ package imports, but also contains some document-level usages of those packages.
\usepackage{LegaleseResearchReportApril2018_packages}
\usepackage{LegaleseResearchReportApril2018_environments}
\usepackage{LegaleseResearchReportApril2018_generic_macros}

\usepackage[top=1.5in]{geometry}
%\usepackage{geometry}


\usepackage{draftwatermark}
\SetWatermarkText{DRAFT}
\SetWatermarkAngle{360}
\SetWatermarkVerCenter{80pt}
\SetWatermarkScale{2}
\SetWatermarkLightness{.85}

\newcommand{\minil}{\textsf{MiniL4}}

\newcommand{\term}[1]{\EM{\textsf{\hyperref[#1]{#1}}}\xspace}
\newcommand{\termz}[2]{\EM{\textsf{\hyperref[#1]{#2}}}\xspace}

\newcommand{\lsm}{\term{LSM}}
\newcommand{\lsms}{\termz{LSM}{LSMs}}
\newcommand{\lsmclass}[1]{\textsf{\hyperref[lsmclass]{LSM}}(#1)}
\newcommand{\timelesslsmclass}[1]{\textsf{\hyperref[timeless-lsmclass]{timeless-LSM}}(#1)}

\newcommand{\actor}{\term{actor}}
\newcommand{\actors}{\termz{actor}{actors}}
\newcommand{\codeactor}{\termz{codeactor}{Code}}

\newcommand{\timeunit}{\term{timeunit}}
\newcommand{\timestamp}{\term{timestamp}}
\newcommand{\timestamps}{\termz{timestamp}{timestamps}}
\newcommand{\tnext}{\EM{t_{\textsf{next}}}}
\newcommand{\tlast}{\EM{t_{\textsf{last}}}}
% didn't work :-/ nor did \clock of wasysym
%\usepackage{clock}
%\ClockFrametrue
%\ClockStyle1
%\newcommand{\timestamp}{\clocktime}

\newcommand{\statevar}{\termz{statevars}{statevar}}
\newcommand{\statevars}{\term{statevars}}
%\newcommand{\VDom}{\termz{statevartypes}{statevar-domains}}
%\newcommand{\VDom}{\termz{statevartypes}{VDom}}
\newcommand{\VDom}{\termz{statevartypes}{Global}}
\newcommand{\initvals}{\term{initvals}}

\newcommand{\ename}{\termz{ename}{event}}
\newcommand{\einst}{\termz{einst}{event-instance}}
\newcommand{\penames}{\termz{penames}{\text{party-events}}}
\newcommand{\oenames}{\termz{oenames}{\text{oracle-events}}}
\newcommand{\denames}{\termz{denames}{\text{deadline-events}}}
\newcommand{\einsts}{\termz{einst}{event-instances}}
%\newcommand{\eparamtypes}[1]{\textsf{\hyperref[eparamtypes]{Dom}}_{#1}}
\newcommand{\eparamtypes}[1]{\textsf{\hyperref[eparamtypes]{Param}}_{#1}}

%\newcommand{\eparamtypes}[1]{\textsf{\hyperref[eparamtypes]{param-types}}_{#1}}

\newcommand{\ehandler}{\termz{ehandler}{event-handler}}
\newcommand{\erule}{\termz{erule}{event-rule}}
\newcommand{\erules}{\termz{erule}{event-rules}}
\newcommand{\enabled}{\term{enabled}}
\newcommand{\compatible}{\term{compatible}}
\newcommand{\compatiblewith}{\termz{compatiblewith}{compatible with}}
\newcommand{\enabledguard}{\termz{enabledguard}{enabled-guard}}
\newcommand{\enabledguards}{\termz{enabledguard}{enabled-guards}}
\newcommand{\params}[1]{{\sf \hyperref[params]{params}}_{#1}} %for deadline event rules
\newcommand{\paramspart}[2]{{\sf \hyperref[paramspart]{params}}_{#1}^{#2}}
% re for 'rule enabled'
\newcommand{\reguard}[1]{\EM{\textsf{\hyperref[reguard]{enabled-guard}}_{#1}}}
\newcommand{\deadfn}[1]{\EM{\textsf{\hyperref[deadfn]{deadline}}_{#1}}}
% ep for 'event parameters'
\newcommand{\epconstr}[1]{\EM{\textsf{\hyperref[epconstr]{param-constraint}}_{#1}}}
\newcommand{\udc}{\termz{udc}{unambiguous deadline condition}}
\newcommand{\nsc}{\termz{nsc}{never-stuck condition}}
\newcommand{\governs}{\term{governs}}


\newcommand{\sname}{\termz{sname}{situation}}
\newcommand{\startsname}{\termz{startsname}{start-situation}}
\newcommand{\fulfilled}{\term{fulfilled}}
\newcommand{\breached}[1]{\EM{\textsf{\hyperref[breached]{breached}}_{#1}}\xspace}
\newcommand{\shandler}{\termz{shandler}{situation-handler}}
\newcommand{\shandlerof}[1]{\EM{\textsf{\hyperref[shandler]{handler}}_{#1}}\xspace}

\newcommand{\statetransform}[1]{\EM{\textsf{\hyperref[statetransform]{statetransform}}_{#1}}}
\newcommand{\statetransforms}{\EM{\textsf{\hyperref[statetransform]{statetransforms}}}}
\newcommand{\stranspart}[2]{\EM{\textsf{\hyperref[statetransform]{statetransform}}_{#1}^{#2}}}
\newcommand{\assign}[2]{#1 \leftarrow #2}
\newcommand{\cond}[3]{\textsf{if}\, #1 \, \textsf{then} \, #2 \, \textsf{else}\, #3}
\newcommand{\statement}{\term{statement}}
\newcommand{\statements}{\termz{statement}{statements}}
\newcommand{\estatement}[1]{\EM{#1\text{-}\textsf{\hyperref[estatement]{statement}}}}
\newcommand{\estatements}[1]{\EM{#1\text{-}\textsf{\hyperref[estatement]{statements}}}}
%\newcommand{\estatements}[1]{#1-\termz{statement}{statements}}
\newcommand{\stransimpl}{\termz{stransimpl}{statement-implementation}}
\newcommand{\uuc}{\termz{uusc}{unambiguous statevar-update condition}}


\newcommand{\state}{\term{state}}
\newcommand{\statespace}{\termz{statespace}{state space}}

\newcommand{\trace}{\term{trace}}
\newcommand{\wfeseq}{\termz{wfeseq}{well-formed event sequence}}

\newcommand{\Bool}{\textsf{bool}\xspace}
\newcommand{\DT}{\EM{\mathbb{\hyperref[DT]{D}}}\xspace}
\newcommand{\TS}{\EM{\mathbb{\hyperref[TS]{T}}}\xsapce}
\newcommand{\cF}{\EM{\mathcal{F}}\xspace}
\newcommand{\sortsof}[1]{\EM{\textsf{\hyperref[sortsof]{sorts}}(#1)}}

%\author{Dustin Wehr\footnote{dustin.wehr@gmail.com}}
%\author{dustin.wehr@gmail.com}

\title{Legal State Machines, \\
L4, and Formal Verification of Contracts \\
\smaller \smaller Report on Computational Law Research by \extlink{https://legalese.com}{Legalese}\footnote{Contact: dustin.wehr@gmail.com or collective@legalese.com}\larger \larger }
\begin{document}
\maketitle

\begin{abstract}
This report is intended for industry and academics in Computational Law. However, by publication time it should be readable by anyone with an undergraduate level background in computer science or mathematics. We recommend joining \extlink{https://legalese.slack.com/messages/C0SB9HZ1S/}{the \#dsl channel} on \extlink{https://legalese.slack.com}{our Slack workspace}\footnote{https://legalese.slack.com} and introducing yourself if you're planning on spending more than half an hour with this document. %before delving into this. Most of the L4 documentation needs updating/improving, including this document, and Dustin or Meng will be much more motivated to prioritize that if they know there are people waiting for it.

The primary focus of this report is the definition of the unopinionated, unpretentious programming language-independent mathematical model for computational legal contracts that we've developed after a comprehensive review of the literature and months of research. The model, called \textit{Legal State Machines} (\lsms), provides the formal semantics for our prototype open source computational legal contracts DSL L4, but it is intended to be a \textit{necessary substructure of the semantics of any computational legal contracts language that is worth a damn} (and we eagerly invite disputes).\footnote{L4's typesystem (Section \ref{typechecking}), though we are quite proud of it, is an example of a feature that does not meet this high standard. It is plausible that the complication it introduces, when in the presence of other optional language features that (the current version of) L4 does not have, makes its inclusion unjustified.}
% In fact, it would be hard to add L4's typesystem to the definition of \lsms, as \lsms do not even have a term language!}
In programming language theory jargon, \lsms are a denotational semantics.

Legalese is not advocating for the adoption of L4 at this time. We would strongly prefer to join forces with another open source computational contracts DSL project. Our main opinion on this matter is that whatever DSL we align ourselves with, it should have a fragment that fully supports \lsms.
\end{abstract}

\tableofcontents


%\section{Who this is for and how to read it}
\section{Introduction}

We expect the Computational Law community will develop a number of independent, open source, computational contract DSLs, to suit different tastes and focuses, but we hope that the bulk of the work done by the community will be effectively reusable, particularly in statute and contract libraries, formal verification, and visualization. For this reason, not only have we made our DSL L4 completely free and open source, we have also ensured that none of our work on formal verification of contracts is dependent on the fine details of L4 - only on the much simpler mathematical model of Legal State Machines that one can use L4 (or your own DSL!) to construct.

Sections \ref{basics} and \ref{lsmdef} define Legal State Machines. Section \ref{lsmstatic} documents our progress on static analysis for \lsms.

Hovering over (resp. clicking on) most terms in \textsf{{sf font}} should show you a popup of (resp. take you to)  where the term is defined and styled like \defstyle{this}. This might not work in all PDF viewers.


\section{Time, Actors, and Events} \label{basics}
We will always be working with a fixed minimal \firstuse{timeunit}{timeunit}, which will be one of days, hours, minutes, seconds, etc. It is a parameter of the Legal State Machine (\lsm), and should be set to the smallest unit of time that one writes constraints about, or does arithmetic with, in the text of the legal contract one is modelling.  A \firstuse{timestamp}{timestamp} is \text{just} a nonnegative real number\footnote{See a few paragraph below for why it is \RR\, and not \NN.} that we \textit{think of} as being in units \timeunit. It denotes the time since the designated start of the \lsm execution, which is always 0 by definition.
%Let $\TS$ denote the nonnegative reals when used for this purpose.
It is worth emphasizing that \timestamps are distinct from both DateTimes (some standard for calendar dates, clock times, time zones) and TimeDeltas (i.e. durations, which are similar to \timeunit aside from coming in more than one unit), both of which are important datatypes in DSLs such as L4. We have found that there is no advantage, and significant disadvantage (when it comes to formal verification), to having DateTimes or TimeDeltas in the mathematical model.

Fix a set \firstuse{$\DT$}{DT} of basic datatypes, or {\it sorts}, which includes at least \Bool. The \lsm-compatible languages we almost always include $\timestamp$ as well, and will usually include $\ZZ$ and $\RR$. We require that these datatypes are definable types of \href{http://smtlib.cs.uiowa.edu/language.shtml}{SMT-LIB}. It is important to note that SMT-LIB itself allows for rich datatypes, including recursive datatypes\footnote{Though then quantifier free validity is undecidable, so the solver is incomplete.}, but also that a computational contracts DSL such as L4 or Ergo can include types beyond those easily definable in SMT-LIB (see Section \ref{typechecking}).

Fix a finite set of symbols \firstuse{actor}{actor}, which includes:
\begin{PPI}
\item The parties to the contract.
\item Any ``oracles'' that send information to the contract from the environment. In our implementation of SAFE in L4, we have an oracle that decides whether a liquidation, equity, or dissolution event has occurred. Generally, we put an event's announcement in the hands of an oracle when every party has an incentive to lie about it.
\item The special symbol \firstuse{\codeactor}{codeactor}, for events that are initiated by the code of the contract.
\end{PPI}
Before publication of this document, we will likely replace the finite set of party-\actor{s} with a finite set of {\it roles}, and allow for an unbounded number of party-\actors in each role, since that seems to be necessary to model many blockchain smart contracts in a natural way.

Fix a finite set of symbols \firstuse{event}{ename}, and for each such $e$ a parameter type assignment $\eparamtypes{e} \in \DT^*$. Furthermore, partition \ename into three kinds of events:
\begin{PPI}
\item \penames, which are actions done by a party-to-the-contract,
\item \oenames, which provide information from the environment, and
\item \denames, which are transitions mandated by the contract.
\end{PPI}
An \firstuse{event instance}{einst} is a tuple $\tup{e,a,t,\sigma}$ where $e$ is an \ename, $a$ is an \actor, $t$ is a \timestamp, and $\sigma \in \eparamtypes{e}$. The \actor for a deadline \ename is always \codeactor.
%\todo{Alternatively, that's only for party and oracle events. A deadline event only needs the first and fourth components.}

%The  include ``oracle'' or environmental actions ``performed'' by the special \Actor \introx{Env}{Env}. We also use the special \Actor \introx{ContractActor}{Contract} for the \Actor component of \devents.

Event instances are instantaneous,\footnote{We might relax this before publication, after discussion with others in the Computational Law community.} occurring at a particular \timestamp; a real world event with duration is modelled by two such instantaneous \einsts, for the start and end of the real world event. That convention is quite flexible; it easily allows modelling overlapping real-world events, for example. We will see in the next section that a sequence of \einsts that constitutes a valid execution of an \lsm requires strictly increasing time stamps. For example, if the \timeunit is days, then three real-world events that happen in some sequence on the second day would happen at \timestamps $1, 1 + \epsilon_1,  1 + \epsilon_1 + \epsilon_2$, for some $\epsilon_1,\epsilon_2 > 0$. When we need to model two real-world events as truly-simultaneous, we use one event instance to model their cooccurrence \todo{example}. 

For our intended domain of legal contracts, we are not aware of any cogent criticism of requiring instantaneous event instances with strictly increasing timestamps; and \emph{\textbf{we welcome attempts}}. An earlier version of the model, in fact, did not require that timestamps are {\it strictly} increasing, used discrete time, and had what we believe was a very satisfying\footnote{Or ``elegant'', as unscrupulous researchers put it.} justification. However, the justification requires at least another paragraph, and probably several more to adequately defend it. Meanwhile, it offered no advantages in examples, and had one clear disadvantage for formal verification, where the use of integer variables is costly for SMT solvers.\footnote{The best explanation we have for this is not simple. It starts with noting that real arithmetic is decidable (real closed fields), but even quantifier free integer arithmetic is undecidable (diophantine equations). This does not necessarily mean that simple uses of integer variables will be costly, but in practice, as of April 2018, it seems to, at least to us outsiders. We are not aware of any particularly-useful decidable restriction of quantifier free combined real/integer arithmetic, and the currently-implemented heuristics, at least in Z3, are easily fooled.}

\section{Legal State Machines} \label{lsmdef}

A Legal State Machine (\lsm) first of all fixes the definitions of the terms introduced in Section \ref{basics}: \DT, \timeunit, \actor, and \ename. It also includes a finite set of symbols \firstuse{situation}{sname} that must contain at least the symbols:
\begin{PPI}
\item \fulfilled
\item $\breached{X}$ for each nonempty subset $X$ of $\actor \backslash \{\codeactor\}$.\footnote{These are breaches and oracle errors analogous to undifferentiated unhandled exceptions in software. Some well-drafted computational contracts might avoid using them completely.}
%There is also an \etype \intro{$\breaches{X}$} for each such $X$, and $\intro{\breach{X}{t}}$ is defined as the \FSContract \Event $\tup{\breaches{X}, \Env, t}$
\end{PPI}
%, and partitions \ename into three subsets: party event names, oracle event names, and deadline event names.
An \lsm $M$ also has an ordered finite set of symbols \firstuse{\statevars}{statevars}, and an assignment \firstuse{\VDom}{statevartypes} of a datatype from $\DT$ to each. Since the \statevars are ordered, we can take \VDom to be an element of $\DT^*$. $M$ also includes an initial setting \initvals of its \statevars.

The \firstuse{state space}{statespace} of $M$ is the product set
\[ \sname \times \VDom \times \timestamp\] %(element of $\TS$).
and a \firstuse{\state}{state} is an element of the \statespace.

The remainder and bulk of the definition of an \lsm is a mapping from \sname to {\it situation handlers}, and a mapping from \ename to {\it event handlers}.
An \firstuse{\ehandler}{ehandler} for \ename $e$ consists of:
\begin{PPI}
\item a destination \sname.
\item a function \firstuse{\statetransform{e}}{statetransform} of type
\[\timestamp^2 \times \VDom \times \eparamtypes{e} \rarr \VDom\]
\end{PPI}
where the two \timestamp arguments provided to \statetransform{e} will always be the \timestamps of the previous and next \einsts.

Each \sname gets a \firstuse{\shandler}{shandler}, which for now is just a finite set of \erules that satisfy the condition \udc given below. An \firstuse{\erule}{erule} is one of three types: a {\it party rule}, {\it oracle rule}, or {\it deadline rule}. Every \erule \firstuse{\governs}{governs} the applicability of a unique \ename by a unique \actor.\footnote{In L4, we offer syntax for concisely expressing a set of such rules that apply to different elements of \ename and \actor.} Every \erule $r$ has a relation \firstuse{\reguard{r}}{reguard} on 
\[\timestamp \times \VDom\]
where the \timestamp argument is the \timestamp of the previous \einst. Frequently in our examples, \reguard{r} is just the trivial relation \textsf{true}. $r$ is \firstuse{\enabled}{enabled} upon entering its parent situation at the \timestamp $t$ of the previous \einst iff \reguard{r} is true when evaluated at $t$ and the current statevar assignment. 
\centerline{\begin{fmpage}{5.5in}
\begin{remark}[redundancy of $\reguard{r}$ for party/oracle rules] \label{guardredundancy}
With respect to the execution semantics (Section \ref{execution}), it is easy to eliminate $\reguard{r}$ for party and oracle \erules $r$ (though not for deadline \erules), by conjoining $\reguard{r}$ to $\epconstr{r}$. We will do this for some formal verification purposes where the simplification of the model outweighs the cost (in development time) of interpreting errors and traces. From the practical software engineering perspective, on the other hand, we have found it is very natural to split the constraint on when an oracle/party \erule can apply into
\begin{LPPI}
\item The (usually-maximal) part that depends only on the current \state. This is $\reguard{r}$.
\item The part that depends on the next \einst. This is $\epconstr{r}$.
\end{LPPI}
\end{remark}
\end{fmpage}}

\medskip

A deadline event rule $r$ governing the applicability of a deadline \ename $e$ has an additional {\it deadline function} $\firstuse{\deadfn{r}}{deadfn}$ of type
\[ \timestamp \times \VDom \rarr \timestamp\]
where the \timestamp argument is the \timestamp of the previous \einst.
$r$ also has a {\it parameter setter} $\firstuse{\params{r}}{params}$ of type
\[ \timestamp \times \VDom \rarr \eparamtypes{e}  \]
where the two \timestamp arguments are the \timestamps of the previous and next \einsts.

Since deadline \erules cause an event to occur automatically when the rule activates, we would need to either specify what happens when two such rules activate at the same time, or else ensure that can't happen. We take the latter approach.\footnote{Because we see no natural way to pick one over the other. Note that the \erules are not ordered.} For now, we adopt a constraint that is stronger than necessary but especially simple:\footnote{A closer-to-minimal constraint is: when the \enabledguards of two deadline \erules are simultaneously true, their deadline functions cannot yield the same \timestamp (and then the earlier of the two deadlines is used). We have not yet experienced any desire for the extra leniency, but in case we do, it would be easy to allow it.} \\
\noindent \firstuse{\udc}{udc}:  if a \shandler has multiple deadline \erules, then their \enabledguards must be disjoint relations.

As a very basic liveness condition, we want that an \lsm can't get stuck in a \state where no party or oracle \erules will ever be in applicable again, and where there is no deadline \erule that will trigger. We call this the \firstuse{\nsc}{nsc}. 


Each party and oracle event rule $r$ governing the applicability of a party or oracle \ename $e$ has an additional {\it parameter constraint relation} \firstuse{$\epconstr{r}$}{epconstr} on
\[ \timestamp^2 \times \VDom \times \eparamtypes{e}\]
where the two \timestamp arguments are the \timestamps of the previous and next \einsts.
Note that a {\it parameter setter} is a special case of a {\it parameter constraint relation}. Because that special case is used fairly frequently, in L4 we allow party and oracle event rules to use the {\it parameter setter} syntax of deadline event rules instead of their own {\it parameter constraint relation} syntax.
\begin{center}
That completes the definition of a Legal State Machine.
\end{center}

We now define the {\it well-formed event sequences} of an \lsm $M$, which are a superset of the {\it traces} of $M$ defined next.
\begin{defn}[\erule \firstuse{compatible with}{compatiblewith} \einst] 
An \erule $r$ is \compatiblewith an \einst $\tup{e, a, t, \sigma}$ iff $e$ and $a$ are the \ename and \actor that $r$ \governs the applicability of. 
\end{defn}
\begin{defn}[\firstuse{well-formed event sequence}{wfeseq}]
Fix an \lsm $M$. \\ A \wfeseq of $M$ is a sequence of \einsts $E_0,E_1,\ldots$ with strictly-increasing \timestamps such that, if $\tup{e_i, a_i, t_i, \sigma_i}$ is $E_i$, then
\begin{LPPI}
\item The \startsname $s_0$ of $M$ has an \erule \compatiblewith $E_0$
\item Either the destination \sname $s_{i+1}$ of $e_i$ has an \erule \compatiblewith $E_{i+1}$, or else $E_i$ is the final element of the sequence and $s_i$ is \fulfilled or $\breached{X}$ for some $X \subseteq \actor$.
\end{LPPI}
\end{defn}

\subsection{Execution of \lsms} \label{execution}

Let $\tau = E_1, E_2, \dots$ be a (finite or infinite) \wfeseq of $M$. The starting \state $G_0$ is always $\tup{\startsname, 0, \initvals}$. Let $i \geq 0$ be arbitrary. Assume the sequence is a valid trace up to entering $G_i = \tup{s,t,\pi}$. Let $E_i$ be $\tup{e, a, t', \sigma}$. We now define the valid values of $G_{i+1} = \tup{s', t', \pi'}$:
\begin{PPI}

\item If $E_i$ is a party (resp. oracle) \einst, then it must be \compatiblewith some party (resp. oracle) \erule $r$ of $s$ that is \enabled in $G_i$ such that $\epconstr{r}$ is true at $\tup{t, t', \pi, \sigma}$.

\item If $E_i$ is a deadline \einst, then it must be \compatiblewith the unique\footnote{by the \udc} deadline \erule $r$ of $s$ that is enabled in $G_i$ such that $\deadfn{r}(t, \pi) = t'$. Moreover, $\sigma$ must be $\params{r}(t,\pi)$. 

\item $\pi' = \statetransform{e}(t, t', \pi, \sigma)$.

\end{PPI}
Any \wfeseq where $G_i, E_i$ satisfy the above requirements for all $i$ is a valid \trace for $M$.

\subsection{Reducing the Abstraction By One Level}
So far, \lsm is not a complete language, in the sense that it does not have an abstract syntax tree. In particular, we specified that certain components are mathematical {\it functions} or {\it relations}, rather than expressions that define such functions or relations. To recap, those components are as follows, where now we adopt the common convention of writing the types of relations as functions to \Bool.
\smallskip

\noindent {\bf Initial abstract components of \lsm \label{initialabstract}}:
\begin{LPPI}
\item $\statetransform{e} : \timestamp^2 \times \VDom \times \eparamtypes{e} \rarr \VDom$ for each \ename $e$.
\item $\reguard{r} : \timestamp \times \VDom \rarr \Bool$ for each \erule $r$.
\item For each party or oracle \erule $r$ that \governs an \ename $e$:
	\begin{LPPI} 
	\item $\epconstr{r} : \timestamp^2 \times \VDom \times \eparamtypes{e} \rarr \Bool$
	\end{LPPI}
\item For each deadline \erule $r$ that \governs an \ename $e$.
	 \begin{LPPI}
	\item $\deadfn{r} : \timestamp \times \VDom \rarr \timestamp$
	\item $\params{r} : \timestamp \times \VDom \rarr \eparamtypes{e}$ 	
	\end{LPPI}
\end{LPPI}

Despite the lack of concreteness, we saw that there is enough detail that execution can be defined precisely. We {\it could} stop there, but that would mean leaving out of the coming sections some useful details of formal verification routines that are very likely to be needed in any \lsm-compatible DSL. 

In this section, we reduce the {\it description} of the abstraction level significantly, while maintaining the flexibility of being able to define \lsm-compatible languages that range from finite state machines to Turing complete languages.\footnote{Technically, \extlink{https://en.wikipedia.org/wiki/Turing_degree}{beyond Turing complete languages}, but we don't know of any practical uses of such languages!}
Recall that that the set of basic datatypes or {\it sorts} \DT is a parameter to \lsm. After this section, we will have a notion of {\it class of \lsm} that depends only on \DT and a set \cF of functions on the sorts in \DT; that is, each function in such a set \cF is of type $S_1 \times \cdots \times S_k \rarr S_0$ for some $k \geq 0$ and some  $S_0,\ldots,S_k \in \DT$. Note that, for the sake of this report, we take individual elements of the sorts $\DT$ to be $0$-ary functions in $\cF$.

Assume $\timestamp \in \DT$.\footnote{Technically this implies that an extra constraint will be needed to define finite-state machines: roughly, that no \statevars of type \timestamp are allowed, and the functions in \cF cannot depend on their \timestamp arguments, even if \timestamp appears in the function type.} Surprisingly little is needed in the way of additional definitions. Since $\VDom \in \DT^*$ already, the functions $\reguard{r}$, $\epconstr{r}$, and $\deadfn{r}$ are already of the required $\cF$-form. The remaining two categories of functions $\params{r}$ and $\statetransform{e}$ in the bullet-list above simply get replaced by their point-wise components

\begin{LPPI}
\item For each deadline \erule $r$ that \governs an \ename $e$, and each sort $S_i \in \eparamtypes{e}$, a function $\paramspart{r}{i} :  \timestamp \times \VDom \rarr S_i$
\item For each \ename $e$, and each sort $S_i \in \VDom$, a function $\stranspart{e}{i} : \timestamp^2 \times \VDom \times \eparamtypes{e} \rarr S_i$.
\end{LPPI}

We go one step further by introducing some minimal structure into the $\statetransforms$, which has a role in \textcolor{blue}{\hyperref[symbexec]{symbolic execution}}. 
\begin{defn}[\statement, \stransimpl]
For $\ename$ $e$, an \firstuse{\estatement{e}}{statement} is one of:
\begin{PPI}
\item $\assign{x}{f}$ for some $x \in \statevars$ of sort $S$\footnote{i.e. $\VDom(x) = S$} and some function $f$ of type $\timestamp^2 \times \VDom \times \eparamtypes{e} \rarr S$.
\item $\cond{f}{U_1}{U_2}$ for some function $f$ of type $\timestamp^2 \times \VDom \times \eparamtypes{e} \rarr \Bool$ and finite sets of \estatements{e} $U_1, U_2$. 
\end{PPI}
A \firstuse{\stransimpl}{stransimpl} of $\statetransform{e}$ is a set of \estatements{e} that satisfies the \firstuse{\uuc}{uuc}, which says: Consider the rooted tree formed by the set of \estatements{e} \statetransform{e}\footnote{The tree: A set of \estatements{e} is an internal node whose children are the individual \statements, with the top-level set $\statetransform{e}$ itself being the root of the tree. An assignment $\assign{x}{f}$ is a leaf node. A conditional $\cond{f}{U_1}{U_2}$ is a second kind of internal node with two children $U_1$ and $U_2$ (which, observe, are themselves internal nodes of the first kind).}. Any well-typed setting of the \statetransform{e} parameters yields a value of true or false in the ``test'' part $f$ of each conditional node $\cond{f}{U_1}{U_2}$. Consider the subtree formed by dropping the appropriate ``branch'' $U_1$ (if test is false) or $U_2$ (if test is true) of each such node, at every level. Then any \statevar may occur at most once in that subtree.
\end{defn}

We now officially modify the specification of \lsm to say that each \statetransform{e} is a \stransimpl (instead of just being a set of functions of types $\{ \timestamp^2 \times \VDom \times \eparamtypes{e} \rarr \VDom(x) \ | \ x \in \statevars \}$). 

\subsection{Basic Specification: \lsmclass{\cF}}
Since the start of Section \ref{lsmdef}, we've elaborated some details of the initial definition of \lsm, to bring it closer to being a useful subject for formal verification. Here we give just the concise final specification, without explanation of the semantics.

\medskip

Let $\DT$ be a set of sorts (i.e. datatypes, i.e. sets). Let $\cF$ be a set of functions each of type $S_1 \times \cdots \times S_k \rarr S_0$ for some $k \geq 0$ and some $S_0,\ldots,S_k \in \DT$. Then $\cF$ determines a class of \lsms that we denote $\lsmclass{\cF}$, which are defined as follows. For notational simplicity, and to reduce redundancy, we assume that every sort in $\DT$ is in the type of some function in $\cF$, so that we may uniquely determine $\DT$ from $\cF$. Let \firstuse{$\sortsof{\cF}$}{sortsof} be that unique determination. We also assume $\timestamp \in \DT$. 

Backpeddling on ``without explanation of the semantics'' for a moment: Note/recall that when a function in the following definition has a type starting with $\timestamp^2$, that is the \timestamp of the most recent \einst and the \timestamp of a candidate next \einst. When the type starts with just $\timestamp$, it is of the most recent \einst. 

%
%Definition is on
%\pagebreak

\begin{defn}[\firstuse{\lsmclass{\cF}}{lsmclass}]
Let $\DT$ be $\sortsof{\cF}$. An $\lsmclass{\cF}$ model $M$ is given by the following components. To reduce clutter, we omit the superscript $^M$ except at the component's introduction:
\begin{LPPI}
\item $\timeunit^M$ in $\{\text{days, hours, minutes, seconds, \ldots}\}$.
\item Finite sets $\actor^M, \ename^M, \sname^M$, and $\statevar^M$.
\item A mapping $\VDom^M$ from $\statevar$ to \DT.
\item For each $e \in \ename$, a type for its parameters $\eparamtypes{e}^M \in \DT^*$.
\item For each $e \in \ename$, a \stransimpl $\statetransform{e}$, which is a set of $\estatements{e}^M$ that satisfies the \uuc. 
\item For each $s \in \sname$, a \shandler $\shandlerof{s}^M$, which is a finite subset of $\erule^M$ that satisfies the \udc.
\item A finite set $\erule^M$, with two partitions: 
\begin{PPI}
\item {\it party rules}, {\it oracle rules}, and {\it deadline rules}
\item $\{ \shandlerof{s}^M \ | \ s \in \sname \}$
\end{PPI}
\item An $\cF$ function $\reguard{r}^M : \timestamp \times \VDom \rarr \Bool$ for each \erule $r$.
\item For each party or oracle \erule $r$ that \governs an \ename $e$:
\begin{PPI} 
\item An $\cF$-function $\epconstr{r}^M : \timestamp^2 \times \VDom \times \eparamtypes{e} \rarr \Bool$
\end{PPI}
\item For each deadline \erule $r$ that \governs an \ename $e$.
	 \begin{PPI}
	\item An $\cF$-function $\deadfn{r}^M : \timestamp \times \VDom \rarr \timestamp$
	\item For each sort $S_i \in \eparamtypes{e}$, an $\cF$-function $(\paramspart{r}{i})^M :  \timestamp \times \VDom \rarr S_i$
	\end{PPI}
%\item For each \ename $e$, and each sort $S_i \in \VDom$, a function $(\stranspart{e}{i})^M : \timestamp^2 \times \VDom^M \times \eparamtypes{e}^M \rarr S_i$.
\end{LPPI}

\end{defn}


\section{Automated Formal Verification for \lsm} \label{lsmstatic}

\subsection{Satisfiability Modulo Theories (SMT) Technology}
%We use SMT solver tech extensively, but might help.
Familiarity with SMT is not a prerequisite for this document, but if you are unfamiliar and interested, Microsoft's \extlink{https://rise4fun.com/z3/tutorial}{Z3 tutorial} is a fine place to start.

\subsection{Checking the Basic Correctness Conditions}
We will define here how we use an SMT solver to verify the \udc, \nsc, and \uuc.

\subsection{\lsmclass{\cF} Extension: Adding Pre/Postconditions and Invariants}

\subsection{Symbolic Execution} \label{symbexec}
In model checking for expressive models (say, with at least nonlinear integer arithmetic available), usually\footnote{The term ``model checking'' is used rather inconsistently.} an infinite-state model is approximated by a finite or tamely-infinite state model, and correctness properties of the approximation model are checked exhaustively, or exhaustively up to a certain maximum computation path length. In Section \ref{tamelyinfinite} we will consider some cases where approximation is not necessary.

Symbolic execution is a technique for avoiding some of the approximation, especially for avoiding having to approximate unbounded datatypes with bounded ones (e.g. $\RR$ approximated by {\sf float}). We do not do this for the sake of more accurate/faithful correctness theorems. Indeed, most of the time software is executed with bounded numeric datatypes anyway, and even when not, no fixed computer can actually compute with arbitrarily large numbers. Rather, we use symbolic execution because, if there is not actually complex math going on (e.g. any cryptographic functions) in a program, but only the use of functions that puts us outside decidable theories, then we should be able to save a lot of time by analyzing computation paths in axiomatically-defined batches. 

\subsubsection{Initial values, fixed or abstract?}

When we symbolically execute an \lsm, we have a choice about whether to use some, all, or none of the model's \initvals of its \statevars. Generally, the more of them used, the faster \statespace exploration will be. For example, in a loan agreement, we could treat an interest rate as an arbitrary element of $(0,1)$. We would then be proving correctness of the agreement for interests rates that we'll never use, which of course is perfectly fine if the analysis finishes in a reasonable amount of time. Alternatively, we could use fixed values of the interest rate only, and whenever we use a new fixed interest rate, we simply rerun symbolic execution.

%\pagebreak
\subsubsection{Timeless Normal Form for $\lsmclass{\cF}$}
We define a normal form for $\lsmclass{\cF}$ which is not literally ``timeless'', but removes the special significance of \timestamp from the model. This is just to make the symbolic execution algorithm simpler.

First, and unrelated to the following \timestamp-related transformations (but with the same goal of simplifying symbolic execution), eliminate $\reguard{r}$ for each party/oracle \erule $r$, as described in Remark \ref{guardredundancy}. 
\begin{LPPI}
\item Introduce a new \statevar $\tlast$ of sort \timestamp with initial value $0$.\footnote{i.e. $\VDom(\tlast) = \timestamp$ and $\initvals(\tlast) = 0$.}
\item Add a parameter $\tnext$ of sort \timestamp to every \ename.\footnote{i.e. $\eparamtypes{e}(\tnext) = \timestamp$ for every \ename $e$.} 
\item Add $\assign{\tlast}{\tnext}$ to $\statetransform{e}$ for each $e$.
\item Move $\deadfn{r}$ into $\params{r}{\tnext}$ for each deadline \erule $r$.
\item Add $>_{ts} {:} \timestamp^2 \rarr \Bool$ to $\cF$. 
\item Conjoin ($\wedge$) $\tnext >_{ts} \tlast$ to $\epconstr{r}$ for each party/oracle \erule $r$.
\end{LPPI}

We obtain the following slightly simplified \lsm definition:
\begin{defn}[\firstuse{\timelesslsmclass{\cF}}{timeless-lsmclass}]
Let $\DT$ be $\sortsof{\cF}$. $>_{ts} {:} \timestamp \times \timestamp \rarr \Bool$ must be in $\cF$ (and so \timestamp must be in \DT). A $\timelesslsmclass{\cF}$ model $M$ is given by the following components. To reduce clutter, we omit the superscript $^M$ except at the component's introduction:
\begin{LPPI}
\item $\timeunit^M$ in $\{\text{days, hours, minutes, seconds, \ldots}\}$.
\item Finite sets $\actor^M, \ename^M, \sname^M$, and $\statevar^M$.
\item A mapping $\VDom^M$ from $\statevar$ to \DT.
\item For each $e \in \ename$, a type for its parameters $\eparamtypes{e}^M \in \DT^*$.
\item For each $e \in \ename$, a \stransimpl $\statetransform{e}$, which is a set of $\estatements{e}^M$ that satisfies the \uuc. 
\item For each $s \in \sname$, a \shandler $\shandlerof{s}^M$, which is a finite subset of $\erule^M$ that satisfies the \udc.
\item A finite set $\erule^M$, with two partitions: 
\begin{PPI}
\item {\it party rules}, {\it oracle rules}, and {\it deadline rules}
\item $\{ \shandlerof{s}^M \ | \ s \in \sname \}$
\end{PPI}
\item For each party or oracle \erule $r$ that \governs an \ename $e$
    	\begin{PPI} 
	\item An $\cF$-function $\epconstr{r}^M : \VDom \times \eparamtypes{e} \rarr \Bool$
	\end{PPI}
\item For each deadline \erule $r$ that \governs an \ename $e$.
	\begin{PPI}
	\item An $\cF$ function $\reguard{r}^M :  \VDom \rarr \Bool$ for each \erule $r$.
	\item For each sort $S_i \in \eparamtypes{e}$, an $\cF$-function $(\paramspart{r}{i})^M :  \VDom \rarr S_i$
	\end{PPI}
\end{LPPI}

\end{defn}


\subsubsection{Symbolic Execution for \lsmclass{\cF}}




%Because symbolic execution can be used both to search for bugs and to exhaustively check a (sometimes infinite) state space, and which task one is doing determines how one should resolve nondeterminism choices. On the other hand, there are parts of the algorithm that should always proceed deterministically. For this reason, we adopt two styles of defining the algorithm.



%For simplicity, we will give here a symbolic execution algorithm without some simple optimizations that we have implemented. Most notably, we will introduce new constants whenever it's convenient to do so. 
%



%\section{\minil\, - A Minimal \lsm-Compatible DSL} \label{minil4}
%In Section \ref{lsmstatic}, we gave as much detail as we could about our formal verification progress for \lsms. To go further, we need a complete language, 
%\section{Formal Verification for \minil} \label{minil4static}
%\subsection{Symbolic Execution}


\subsection{Exhaustive Model Checking for Finite and Tamely-Infinite State Spaces} \label{tamelyinfinite}
Suppose the only \statevars in an \lsm $M$ are \Bool or enums, and suppose that for every \erule $r$ and \ename $e$ none of $\reguard{r}$, $\deadfn{r}$, $\epconstr{r}$, $\statetransform{e}$, or $\params{r}$ depend on their \timestamp arguments. Then $M$ is equivalent for formal verification purposes to a kind of compressed\footnote{via the boolean \statevars} deterministic finite state machine (FSM). If there are no \statevars, then $M$ is equivalent for formal verification purposes to a normal FSM. Many important properties about FSMs are decidable. For example, if the specification of such a model $M$ is given entirely in terms of a \statespace invariant, then full formal verification can be checked exhaustively by well-known methods.

We may relax the constraint on the functions/predicates that take \timestamp arguments somewhat, allowing constraints that are boolean combinations of atomic formulas of the form \[ \text{(linear fn of $t$,$t'$)} \ (\leq | < | =) \ \text{(linear fn of $t$,$t'$)} \] where $t$ is the current \timestamp and $t'$ is the next. DateTime and TimeDelta literals can be used also, in the higher-level DSL). This results in a computation model close or equivalent to \extlink{https://drum.lib.umd.edu/bitstream/handle/1903/15232/Fontana_umd_0117E_15027.pdf?sequence=1&isAllowed=y}{Timed Automata} with two clocks, one of which is never reset and the other that is  reset after each \einst. We have not yet proved such a reduction, so take it with a grain of salt.

\subsection{Unbounded-Trace Formal Verification with Pre/Postconditions and Invariants}

\subsection{Unexplored: Hard Unbounded-Trace Formal Verification with Interactive Theorem Proving}

\section{Extensions}
\subsection{Unbounded \actor Set}
This is to accommodate smart contracts (aka dapps). It is a \textbf{\underline{very}} tentative proposal.

\newcommand{\unknown}{\term{unknown}}
\newcommand{\role}{\term{role}}
We introduce to the definition of \lsmclass{\cF} another finite set \role, which always include a special symbol \unknown. \unknown is the role of a party (i.e. ethereum address, in the ethereum dapp context) who has never interacted with the contract before, and who was not known to the parties who initiated the contract. It is thus used at most once by any one party. An \einst allowed by an \erule governing \unknown has the side effect of assigning a non-\unknown \role to the party that initiates the \einst.

\section{L4: An Experimental but Practical \lsm-compatible DSL}

\subsection{Type Checking with Subtyping and Intersection Types} \label{typechecking}


\section{Related Work}

This is thoroughly covered by \extlink{https://github.com/legalese/legalese-compiler/blob/master/doc/chapter-201707.org}{Meng's book chapter} and Appendix B of the \extlink{https://conferences.law.stanford.edu/compkworking201709/wp-content/uploads/sites/40/2017/07/WhitePaperDraftfordistroApril32018.pdf}{CodeX whitepaper} {\it Developing a Legal Specification Protocol: Technological Considerations and Requirements.}



\end{document}
