


*****************************************************************************************************
WAIT TO HEAR FROM MENG. I DON'T KNOW ENOUGH ABOUT THE TYPES OF TRANSITIONS TO WORK ON THIS RIGHT NOW.
*****************************************************************************************************







I'll use Form for the type of kinds-of-paperwork, and CSt for the type of company states. I assume we have dozens of Forms, and we might have hundreds eventually.

A Form is defined by a function with the following signature:
(interm:CSt, src:CSt, dest:Cst) -> Iterable[CSt]
where src is the current, real company state, dest is the desired company state, and interm is some intermediate company state.

The set returned by the function is the intermediate company states that
	(a) are reachable from iterm with one instance of this Form, and that
	(b) we are willing to consider for paths from src to dest (this is where the "technically-but-only-superficially-infinite" part comes in - we don't want to consider company states with an investor named Bob if "Bob" doesn't occur in either src or dest, for example)*
*Alternatively, the return value can be a lazy infinite priority queue.

We also have a function (or a suite of functions, but we are only using one at any given time)
pathWeight(path:Seq[CState]) -> Float
A simple such function is the length of the path. Eventually we might want to generalize this to
strategyWeight(strat:EdgeWeightedDAG[CState]) -> Float
See thread https://legalese.slack.com/archives/C0SB9HZ1S/p1519193401000012



