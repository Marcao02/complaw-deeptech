%useTabs
%!TEX useTabs
\documentclass[12pt]{article}
% Organization note: LegaleseResearchReportApril2018_packages.sty is _mostly_ package imports, but also contains some document-level usages of those packages.
\usepackage{LegaleseResearchReportApril2018_packages}
\usepackage{LegaleseResearchReportApril2018_environments}
\usepackage{LegaleseResearchReportApril2018_generic_macros}

\usepackage{proof}
\newcommand{\stackone}[2]{\deduce{#1}{#2}}
\newcommand{\stacktwo}[3]{\deduce{#1}{\deduce{#2}{#3}}}
\newcommand{\stackthree}[4]{\deduce{#1}{\deduce{#2}{\deduce{#3}{#4}}}}

\usepackage[top=1.3in]{geometry}
%\usepackage{geometry}


\newcommand*{\mybox}[1]{\centerline{\begin{fmpage}{5.5in}#1\end{fmpage}}}

\usepackage{draftwatermark}
\SetWatermarkText{DRAFT}
\SetWatermarkAngle{360}
\SetWatermarkVerCenter{80pt}
\SetWatermarkScale{2}
\SetWatermarkLightness{.85}

\newcommand{\minil}{\textsf{MiniL4}}

\newcommand{\term}[1]{\EM{\textsf{\hyperref[#1]{#1}}}\xspace}
\newcommand{\termz}[2]{\EM{\textsf{\hyperref[#1]{#2}}}\xspace}

%\newcommand{\lsmslong}{Contract State Machines\xspace}
%\newcommand{\lsm}{\texorpdfstring{\termz{lsm}{CSM}}{CSM}}
%\newcommand{\lsms}{\texorpdfstring{\termz{lsm}{CSMs}}{CSMs}}
%\newcommand{\lsmclass}[1]{\texorpdfstring{\textsf{\hyperref[lsmclass]{CSM}}(#1)}{CSM(F)}}
%\newcommand{\timelesslsmclass}[1]{\texorpdfstring{
%	\textsf{\hyperref[timeless-lsmclass]{timeless-CSM}}(#1)}
%	{timeless-CSM(F)}}
\newcommand{\lsmslong}{Legal State Machines\xspace}
\newcommand{\lsm}{\texorpdfstring{\termz{lsm}{LSM}}{LSM}}
\newcommand{\lsms}{\texorpdfstring{\termz{lsm}{LSMs}}{LSMs}}
\newcommand{\lsmclass}[1]{\texorpdfstring{\textsf{\hyperref[lsmclass]{LSM}}(#1)}{LSM(F)}}
\newcommand{\timelesslsmclass}[1]{\texorpdfstring{
	\textsf{\hyperref[timeless-lsmclass]{timeless-LSM}}(#1)}
	{timeless-LSM(F)}}


\newcommand{\actor}{\term{actor}}
\newcommand{\actors}{\termz{actor}{actors}}
\newcommand{\codeactor}{\termz{codeactor}{Code}}

\newcommand{\timeunit}{\term{timeunit}}
\newcommand{\timestamp}{\term{timestamp}}
\newcommand{\timestamps}{\termz{timestamp}{timestamps}}
\newcommand{\vts}{\texttt{t}}
\newcommand{\tnext}{\EM{\vts_{\textsf{next}}}}
\newcommand{\tlast}{\EM{\vts_{\textsf{last}}}}
% didn't work :-/ nor did \clock of wasysym
%\usepackage{clock}
%\ClockFrametrue
%\ClockStyle1
%\newcommand{\timestamp}{\clocktime}

% ------------------
% STATE VARS
% ------------------
\newcommand{\statevar}{\termz{statevars}{statevar}}
\newcommand{\statevars}{\term{statevars}}
%\newcommand{\svsorts}{\termz{svsorts}{statevar-domains}}
%\newcommand{\svsorts}{\termz{svsorts}{VDom}}
\newcommand{\svsorts}{\termz{svsorts}{\EM{\textsf{\hyperref[svsorts]{type}}_{\textsf{state}}}}}
\newcommand{\initvals}{\term{initvals}}


% --------------------------------------------------
% EVENTS AND THEIR PARAMETERS
% --------------------------------------------------
\newcommand{\ename}{\termz{ename}{event}}
\newcommand{\enames}{\termz{ename}{events}}
\newcommand{\einst}{\termz{einst}{event-instance}}
\newcommand{\penames}{\termz{penames}{\text{party-events}}}
\newcommand{\oenames}{\termz{oenames}{\text{oracle-events}}}
\newcommand{\denames}{\termz{denames}{\text{deadline-events}}}
\newcommand{\einsts}{\termz{einst}{event-instances}}
\newcommand{\eppartsorts}[1]{\textsf{\hyperref[eppartsorts]{type}}_{#1}}
\newcommand{\edest}[1]{\textsf{\hyperref[edest]{dest}}_{#1}}
\newcommand{\eppart}[2]{\EM{\hyperref[eppart]{\textsf{x}}_{#1}^{#2}}\xspace}
\newcommand{\eparams}[1]{#1\textsf{-\hyperref[eparams]{params}}}
\newcommand{\eparam}[1]{#1\textsf{-\hyperref[eparams]{param}}}



% ---------------------
% EVENT RULES
% ---------------------
\newcommand{\erule}{\termz{erule}{event-rule}}
\newcommand{\erules}{\termz{erule}{event-rules}}
\newcommand{\ehandler}{\termz{ehandler}{event-handler}}
\newcommand{\ehandlerof}[1]{\EM{\textsf{\hyperref[ehandler]{handler}}_{#1}}\xspace}
\newcommand{\enabled}{\term{enabled}}
\newcommand{\compatible}{\term{compatible}}
\newcommand{\compatiblewith}{\termz{compatiblewith}{compatible with}}
\newcommand{\enabledguard}{\termz{enabledguard}{enabled-guard}}
\newcommand{\enabledguards}{\termz{enabledguard}{enabled-guards}}
\newcommand{\psetter}[1]{{\sf \hyperref[psetter]{psetter}}_{#1}} %for deadline event rules only
\newcommand{\psetterpart}[2]{{\sf \hyperref[psetterpart]{psetter}}_{#1}^{#2}}
\newcommand{\reguard}[1]{\EM{\textsf{\hyperref[reguard]{enabled-guard}}_{#1}}} % re for 'rule enabled'
\newcommand{\deadfn}[1]{\EM{\textsf{\hyperref[deadfn]{deadline}}_{#1}}} % ep for 'event parameters'
\newcommand{\eppartconstr}[1]{\EM{\textsf{\hyperref[epconstr]{param-constraint}}_{#1}}}
\newcommand{\governs}{\term{governs}}
\newcommand{\prules}{\termz{prules}{party-rules}}
\newcommand{\orules}{\termz{orules}{oracle-rules}}
\newcommand{\drules}{\termz{drules}{deadline-rules}}


% ------------------
% SITUATIONS
% ------------------
\newcommand{\sname}{\termz{sname}{situation}}
\newcommand{\snames}{\termz{sname}{situations}}
\newcommand{\startsname}{\termz{startsname}{start-situation}}
\newcommand{\fulfilled}{\term{fulfilled}}
\newcommand{\breached}[1]{\EM{\textsf{\hyperref[breached]{breached}}_{#1}}\xspace}
\newcommand{\termin}{\termz{termin}{terminated}}
\newcommand{\shandler}{\termz{shandler}{situation-handler}}
\newcommand{\shandlerof}[1]{\EM{\textsf{\hyperref[shandler]{handler}}_{#1}}\xspace}


% -------------------------------
% STATE TRANSFORMS
% -------------------------------
\newcommand{\statetransform}[1]{\EM{\textsf{\hyperref[statetransform]{statetransform}}_{#1}}}
\newcommand{\statetransforms}{\EM{\textsf{\hyperref[statetransform]{statetransforms}}}}
\newcommand{\stranspart}[2]{\EM{\textsf{\hyperref[statetransform]{statetransform}}_{#1}^{#2}}}
\newcommand{\assign}[2]{#1 \leftarrow #2}
\newcommand{\cond}[3]{\textsf{if}\, #1 \, \textsf{then} \, #2 \, \textsf{else}\, #3}
\newcommand{\statement}{\term{statement}}
\newcommand{\statements}{\termz{statement}{statements}}
\newcommand{\estatement}[1]{\EM{#1\text{-}\textsf{\hyperref[estatement]{statement}}}}
\newcommand{\estatements}[1]{\EM{#1\text{-}\textsf{\hyperref[estatement]{statements}}}}
%\newcommand{\estatements}[1]{#1-\termz{statement}{statements}}
\newcommand{\stransimpl}{\termz{stransimpl}{conditional-tree}}
\newcommand{\statementsetexec}{\termz{statementsetexec}{exec}}


\newcommand{\state}{\term{state}}
\newcommand{\statespace}{\termz{statespace}{state space}}

\newcommand{\trace}{\term{trace}}
\newcommand{\traces}{\termz{trace}{traces}}
\newcommand{\wfeseq}{\termz{wfeseq}{well-formed event sequence}}


\newcommand{\Bool}{\textsf{bool}\xspace}
	\newcommand{\True}{\EM{\text{true}}\xspace}
	\newcommand{\False}{\EM{\text{false}}\xspace}
\newcommand{\DT}{\EM{\mathbb{\hyperref[DT]{D}}}\xspace}
\newcommand{\TS}{\EM{\mathbb{\hyperref[TS]{T}}}\xsapce}
\newcommand{\cF}{\EM{\mathcal{F}}\xspace}
\newcommand{\cLofF}{\EM{\mathcal{L}_{\mathcal{F}}}\xspace}
\newcommand{\cFstar}{\EM{\mathcal{F}^*}\xspace}
\newcommand{\sortsof}[1]{\EM{\textsf{\hyperref[sortsof]{sorts}}(#1)}}

\newcommand{\smtvar}{\termz{smtvar}{smt-var}}
\newcommand{\smtvars}{\termz{smtvar}{smt-vars}}

\newcommand{\smtfterms}{\termz{smtfterm}{\text{smt}-\cF-\text{terms}}}
\newcommand{\smtfterm}{\termz{smtfterm}{\text{smt}-\cF-\text{term}}}

\newcommand{\srcfterms}{\termz{srcfterm}{\text{src}-\cF-\text{terms}}}
\newcommand{\srcfterm}{\termz{srcfterm}{\text{src}-\cF-\text{term}}}

\newcommand{\ffnsymb}{\termz{ffnsymb}{\cF-\text{fn-symbol}}}
\newcommand{\esubst}[1]{\EM{#1\textsf{\hyperref[esubst]{-subst}}}\xspace}
\newcommand{\info}[1]{\EM{\textsf{\hyperref[info]{info}}(#1)}\xspace}



\newcommand{\actorrule}[3]{#1 \textit{ may } (#2 \textit{ where } #3)}
\newcommand{\deadrule}[3]{\textit{if } #3 \textit{ then fire }#1(#2)}
\newcommand{\yields}[2]{#1 \rightsquigarrow #2}
\newcommand{\svtosmt}{\pi}
\newcommand{\eptosmt}{\sigma}
\newcommand{\vx}{\vec{x}}
\newcommand{\vv}{\vec{v}}
\newcommand{\rv}{\EM{\textsf{rv}}\xspace}
%\newcommand{\full}[2]{\tup{#1,#2}}
\newcommand{\full}[2]{#2}

%\newcommand{\sv}[1]{q_{#1}}
\newcommand{\sv}[1]{\EM{\hyperref[sv]{\textsf{q}}_{#1}}\xspace}

\newcommand{\bterm}[1]{\EM{\left< \text{#1} \right>}}
\newcommand{\serv}{\termz{serv}{\II}}

\newcommand{\isconsistent}[1]{\EM{#1 \textsf{ \hyperref[consistent]{consistent}}}\xspace}

%\newcommand{\smtfterms}{\EM{\cF-text{terms}}\xspace}

\newcommand{\uuc}{\termz{uuc}{unambiguous statevar-update condition}}
\newcommand{\udc}{\termz{udc}{unambiguous deadline\- condition}}
\newcommand{\nsc}{\termz{nsc}{never-stuck condition}}
\newcommand{\noreadbeforewrite}{\termz{nowritebeforeread}{no read-before-write condition}}

%\author{Dustin Wehr\footnote{dustin.wehr@gmail.com}}
%\author{dustin.wehr@gmail.com}

\title{\lsmslong, the language L4,\\
and Formal Verification of Legal Contracts \\
\smaller \smaller Report on Open Source Computational Law Research by \extlink{https://legalese.com}{Legalese}\footnote{Contact: dustin.wehr@gmail.com or collective@legalese.com}\larger \larger }
\begin{document}
\maketitle

\begin{abstract}
This report is intended for industry and academics in Computational Law. However, by publication time it should be readable by anyone with an undergraduate level background in computer science or mathematics. We recommend joining \extlink{https://legalese.slack.com/messages/C0SB9HZ1S/}{the \#dsl channel} on \extlink{https://legalese.slack.com}{our Slack workspace} and introducing yourself if you're planning on spending more than an hour with this document. %before delving into this. Most of the L4 documentation needs updating/improving, including this document, and Dustin or Meng will be much more motivated to prioritize that if they know there are people waiting for it.

The primary focus of this report is the definition of the unpretentious, programming language-independent mathematical model for computational legal contracts that we've developed after a comprehensive review of the literature and months of research. The model, (tentatively) called \textit{\lsmslong} (\lsms), provides the formal semantics for our prototype open source computational legal contracts DSL L4. But more importantly, it is intended to be a \textit{necessary substructure of the semantics of any computational legal contracts language that is worth a damn} (and we eagerly invite disputes).\footnote{L4's typesystem (Section \ref{typechecking}), though we are quite proud of it, is an example of a feature that does not meet this high standard. It is plausible that the complication it introduces, when in the presence of other optional language features that (the current version of) L4 does not have, makes its inclusion unjustified.}
% In fact, it would be hard to add L4's typesystem to the definition of \lsms, as \lsms do not even have a term language!}
In programming language theory jargon, \lsms are a denotational semantics. We will argue that a single-threaded, non-distributed, event-driven computation model is best suited for legal contracts, despite not being the first thing one thinks of for multi-agent computation.
%Legalese is not advocating for the adoption of L4 at this time. We would prefer to join forces with another open source computational contracts DSL project, but we are also prepared not to. Our main opinion on this matter is that whatever DSL we align ourselves with, it should have a fragment that fully supports \lsms.
\end{abstract}
\pagebreak

\tableofcontents

\section{How to read}

%\section{Who this is for and how to read it}
\section{Introduction}

We expect the Computational Law community will develop a number of independent, open source, computational contract DSLs, to suit different tastes and focuses, but we hope that the bulk of the work done by the community will be effectively reusable, particularly in statute and contract libraries, formal verification, and visualization. For this reason, not only have we made our DSL L4 completely free and open source, we have also ensured that none of our work on formal verification of contracts is dependent on the fine details of L4 - only on the much simpler mathematical model of \lsmslong that one can use L4 (or your own DSL!) to construct.

Sections \ref{basics} and \ref{lsmdef} define \lsmslong. Section \ref{lsmstatic} documents our progress on static analysis for \lsms.

Hovering over (resp. clicking on) most terms in \textsf{{sf font}} should show you a popup of (resp. take you to)  where the term is defined and styled like \defstyle{this}. This might not work in all PDF viewers.


\section{Time, Actors, and Events} \label{basics}
We will always be working with a fixed minimal \anchorfor{timeunit}{timeunit}, which will be one of days, hours, minutes, seconds, etc. It is a parameter of the Legal State Machine (\lsm), and should be set to the smallest unit of time that one writes constraints about, or does arithmetic with, in the text of the legal contract one is modelling.  A \anchorfor{timestamp}{timestamp} is \text{just} a nonnegative real number\footnote{See a few paragraph below for why it is \RR\, and not \NN.} that we \textit{think of} as being in units \timeunit. It denotes the time since the designated start of the \lsm execution, which is always 0 by definition.
%Let $\TS$ denote the nonnegative reals when used for this purpose.
It is worth emphasizing that \timestamps are distinct from both DateTimes (some standard for calendar dates, clock times, time zones) and TimeDeltas (i.e. durations, which are similar to \timeunit aside from coming in more than one unit), both of which are important datatypes in DSLs such as L4. We have found that there is no advantage, and significant disadvantage (when it comes to formal verification), to having DateTimes or TimeDeltas in the mathematical model.

Fix a set \anchorfor{$\DT$}{DT} of basic datatypes, or {\it sorts}, which includes at least \Bool. The \lsm-compatible languages we almost always include $\timestamp$ as well, and will usually include $\ZZ$ and $\RR$. We require that these datatypes are definable types of \href{http://smtlib.cs.uiowa.edu/language.shtml}{SMT-LIB}. It is important to note that SMT-LIB itself allows for rich datatypes, including recursive datatypes\footnote{Though then quantifier free validity is undecidable, so the prover is incomplete.}, but also that a computational contracts DSL such as L4 or Ergo can include types beyond those easily definable in SMT-LIB (see Section \ref{typechecking}).
\medskip

\mybox{\begin{bnote} \label{nameconvention}
We will skip specifying that various symbol sets are disjoint. Any two symbol sets that you might expect to be disjoint, are required to be disjoint.\\
Also, every typed symbol has a dedicated type (i.e. element of $\DT$ for various variables, function types $\DT^* \rarr \DT$ for function symbols), regardless of its scope. We will thus (eventually) not have as much type-assignment notation as is common in programming language research. A user-facing DSL such as L4 or Ergo will lift this restriction.
\end{bnote}}
%\mybox{\begin{bnote}
%
%\end{bnote}}
%

\medskip

\noindent Fix a finite set of symbols \anchorfor{actor}{actor}, which includes:
\begin{PPI}
\item The parties to the contract, who announce action-events, which are the elements of the event stream most responsible for driving a contract.
\item Any ``oracles'' that send information to the contract from the environment. In our implementation of Y-Combinator's SAFE in L4, we have an oracle that decides whether a liquidation, equity, or dissolution event has occurred, in case the company fails to announce it. % Generally, we put an event's announcement in the hands of an oracle when every party has an incentive to lie about it.
\item The special symbol \anchorfor{\codeactor}{codeactor}, for events that are initiated by the code of the contract.
\end{PPI}
\mybox{\begin{bnote} \label{roles}
Before publication of this document, we will likely replace the finite set of party-\actor{s} with a finite set of {\it roles}, and allow for an unbounded number of party-\actors in each role, since that seems to be necessary to model many blockchain smart contracts in a natural way.
\end{bnote}}
Fix a finite set of symbols \anchorfor{event}{ename}, and for each such $e$ a parameter type assignment $\anchorfor{\eppartsorts{e}}{eppartsorts} \in \DT^*$. Furthermore, partition \ename into three kinds of events:
\begin{PPI}
\item \anchorfor{\penames}{penames}, which are actions done by a party-to-the-contract,
\item \anchorfor{\oenames}{oenames}, which provide information from the environment, and
\item \anchorfor{\denames}{denames}, which are transitions mandated by the contract.
\end{PPI}
An \anchorfor{event instance}{einst} is a tuple $\tup{e,a,\vts,\sigma}$ where $e$ is an \ename, $a$ is an \actor, $\vts$ is a \timestamp, and $\sigma \in \eppartsorts{e}$. The \actor for a deadline \ename is always \codeactor.
%\todo{Alternatively, that's only for party and oracle events. A deadline event only needs the first and fourth components.}

%The  include ``oracle'' or environmental actions ``performed'' by the special \Actor \introx{Env}{Env}. We also use the special \Actor \introx{ContractActor}{Contract} for the \Actor component of \devents.

Event instances are instantaneous,\footnote{We might relax this before publication, after discussion with others in the Computational Law community.} occurring at a particular \timestamp; a real world event with duration is modelled by two such instantaneous \einsts, for the start and end of the real world event. That convention is quite flexible; it easily allows modelling overlapping real-world events, for example. We will see in the next section that a sequence of \einsts that constitutes a valid execution of an \lsm requires strictly increasing time stamps. For example, if the \timeunit is days, then three real-world events that happen in some sequence on the second day would happen at \timestamps $1, 1 + \epsilon_1,  1 + \epsilon_1 + \epsilon_2$, for some $\epsilon_1,\epsilon_2 > 0$. When we need to model two real-world events as truly-simultaneous, we use one event instance to model their cooccurrence \todo{example}.

For our intended domain of legal contracts, we are not aware of any cogent criticism of requiring instantaneous event instances with strictly increasing timestamps; and \emph{\textbf{we welcome attempts}}. An earlier version of the model, in fact, did not require that timestamps are {\it strictly} increasing, used discrete time, and had what we believe was a very satisfying\footnote{Or ``elegant'', as unscrupulous researchers put it.} justification. However, the justification requires at least another paragraph, and probably several more to adequately defend it. Meanwhile, it offered no advantages in examples, and had one clear disadvantage for formal verification, where the use of integer variables is costly for SMT provers.\footnote{The best explanation we have for this is not simple. It starts with noting that real arithmetic is decidable (real closed fields), but even quantifier free integer arithmetic is undecidable (diophantine equations). This does not necessarily mean that simple uses of integer variables will be costly, but in practice, as of April 2018, it seems to, at least to us outsiders. We are not aware of any particularly-useful decidable restriction of quantifier free combined real/integer arithmetic, and the currently-implemented heuristics, at least in Z3, are easily fooled.}

\section{\lsmslong} \label{lsmdef}

A Legal State Machine (\anchorfor{\lsm}{lsm}) first of all fixes the definitions of the terms introduced in Section \ref{basics}: \DT, \timeunit, \actor, and \ename. It also includes a finite set of symbols \anchorfor{situation}{sname} that must contain at least the symbols:
\begin{PPI}
\item \anchorfor{\fulfilled}{fulfilled}, for handled contract termination.
\item $\anchorfor{\breached{A}}{breached}$ for each nonempty subset $A$ of $\actor \backslash \{\codeactor\}$.\footnote{These are breaches and oracle errors analogous to undifferentiated, unhandled exceptions in normal programming languages. Some well-drafted computational contracts might avoid using them completely.}
\end{PPI}
Let \anchorfor{\termin}{termin} be the union of those symbols.%, i.e.  $\{\fulfilled\} \cup \{\breached{A} \ | \ \text{nonempty } A \subseteq \actor\}$.

%, and partitions \ename into three subsets: party event names, oracle event names, and deadline event names.
An \lsm $M$ also has an ordered finite set of symbols \anchorfor{\statevars}{statevars}, and an assignment \anchorfor{\svsorts}{svsorts} of a datatype from $\DT$ to each. Since the \statevars are ordered, we can take \svsorts to be an element of $\DT^*$. $M$ also includes an initial setting \anchorfor{\initvals}{initvals} of its \statevars, and designates one of the \snames its \anchorfor{\startsname}{startsname}.

The \anchorfor{state space}{statespace} of $M$ is the product set
\[ \sname \times \svsorts \times \timestamp\] %(element of $\TS$).
and a \anchorfor{\state}{state} is an element of the \statespace.

The remainder and bulk of the definition of an \lsm is a mapping from \sname to {\it situation handlers}, and a mapping from \ename to {\it event handlers}.
An \anchorfor{\ehandler}{ehandler} for \ename $e$ consists of:
\begin{PPI}
\item $\anchorfor{\edest{e}}{edest} \in \sname$, the destination \sname that $e$ always transitions to.
\item a function \anchorfor{\statetransform{e}}{statetransform} of type
\[\timestamp^2 \times \svsorts \times \eppartsorts{e} \rarr \svsorts\]
\end{PPI}
where the two \timestamp arguments provided to \statetransform{e} will always be the \timestamps of the previous and next \einsts.

Each \sname gets a \anchorfor{\shandler}{shandler}, which for now is just a finite set of \erules that satisfy the condition \udc given below. The set \anchorfor{\erule}{erule} is partitioned into: \prules, \orules, and \drules. Every \erule \anchorfor{\governs}{governs} the applicability of a unique \ename ( \penames, \oenames, and \denames) by a unique \actor.\footnote{In L4, we offer syntax for concisely expressing a set of such rules that apply to different elements of \ename and \actor.} Every \erule $r$ has a relation \anchorfor{\reguard{r}}{reguard} on
\[\timestamp \times \svsorts\]
where the \timestamp argument is the \timestamp of the previous \einst. Frequently in our examples, \reguard{r} is just the trivial relation \True. $r$ is \anchorfor{\enabled}{enabled} upon entering its parent situation at the \timestamp $\vts$ of the previous \einst iff \anchorfor{\reguard{r}}{enabledguard} is \True when evaluated at $\vts$ and the current statevar assignment.

%\centerline{\begin{fmpage}{5.5in}
\begin{bnote}[redundancy of $\reguard{r}$ for party/oracle rules] \label{guardredundancy}
With respect to the execution semantics (Section \ref{execution}), it is easy to eliminate $\reguard{r}$ for party and oracle \erules $r$ (though not for deadline \erules), by conjoining $\reguard{r}$ to $\eppartconstr{r}$. We will do this for some formal verification purposes where the simplification of the model outweighs the cost (in development time) of interpreting errors and \traces. From the practical software engineering perspective, on the other hand, we have found it is very natural to split the constraint on when an oracle/party \erule can apply into
\begin{LPPI}
\item The (usually-maximal) part that depends only on the current \state. This is $\reguard{r}$.
\item The part that depends on the next \einst. This is $\eppartconstr{r}$.
\end{LPPI}
\end{bnote}
%\end{fmpage}}

\medskip

A deadline event rule $r$ governing the applicability of a deadline \ename $e$ has an additional {\it deadline function} $\anchorfor{\deadfn{r}}{deadfn}$ of type
\[ \timestamp \times \svsorts \rarr \timestamp\]
where the \timestamp argument is the \timestamp of the previous \einst.
$r$ also has a {\it parameter setter} $\anchorfor{\psetter{r}}{psetter}$ of type
\[ \timestamp \times \svsorts \rarr \eppartsorts{e}  \]
where the two \timestamp arguments are the \timestamps of the previous and next \einsts.

Since deadline \erules cause an event to occur automatically when the rule activates, we would need to either specify what happens when two such rules activate at the same time, or else ensure that can't happen. We take the latter approach.\footnote{Because we see no natural way to pick one over the other. Note that the \erules are not ordered.} For now, we adopt a constraint that is stronger than necessary but especially simple:\footnote{A closer-to-minimal constraint is: when the \enabledguards of two deadline \erules are simultaneously \True, their deadline functions cannot yield the same \timestamp (and then the earlier of the two deadlines is used). We have not yet experienced any desire for the extra leniency, but in case we do, it would be easy to allow it.} \\
\noindent \anchorfor{\udc}{udc}:  if a \shandler has multiple deadline \erules, then their \enabledguards must be disjoint relations.

As a very basic liveness condition, we want that an \lsm can't get stuck in a \state where no party or oracle \erules will ever be in applicable again, and where there is no deadline \erule that will trigger. We call this the \anchorfor{\nsc}{nsc}.


Each party and oracle event rule $r$ governing the applicability of a party or oracle \ename $e$ has an additional {\it parameter constraint relation} \anchorfor{$\eppartconstr{r}$}{epconstr} on
\[ \timestamp^2 \times \svsorts \times \eppartsorts{e}\]
where the two \timestamp arguments are the \timestamps of the previous and next \einsts.
Note that a {\it parameter setter} is a special case of a {\it parameter constraint relation}. Because that special case is used fairly frequently, in L4 we allow party and oracle event rules to use the {\it parameter setter} syntax of deadline event rules instead of their own {\it parameter constraint relation} syntax.
\begin{center}
That completes the definition of a Legal State Machine.
\end{center}

We now define the {\it well-formed event sequences} of an \lsm $M$, which are a superset of the \traces of $M$ defined next.
\begin{defn}[\erule \anchorfor{compatible with}{compatiblewith} \einst]
An \erule $r$ is \\ \compatiblewith an \einst $\tup{e, a, t, \sigma}$ iff $e$ and $a$ are the \ename and \actor that $r$ \governs the applicability of.
\end{defn}
\begin{defn}[\anchorfor{well-formed event sequence}{wfeseq}]
Fix an \lsm $M$. \\ A \wfeseq of $M$ is a sequence of \einsts $E_0,E_1,\ldots$ with strictly-increasing \timestamps such that, if $\tup{e_i, a_i, \vts_i, \sigma_i}$ is $E_i$, then
\begin{LPPI}
\item The \startsname $s_0$ of $M$ has an \erule \compatiblewith $E_0$
\item Either the destination \sname $s_{i+1}$ of $e_i$ has an \erule \compatiblewith $E_{i+1}$, or else $E_i$ is the final element of the sequence and $s_i$ is \fulfilled or $\breached{A}$ for some nonempty $A \subseteq \actor$.
\end{LPPI}
\end{defn}

\subsection{\lsm Execution} \label{execution}

Let $\tau = E_1, E_2, \dots$ be a (finite or infinite) \wfeseq of $M$. The starting \state $G_0$ is always $\tup{\startsname, 0, \initvals}$. Let $i \geq 0$ be arbitrary. Assume the sequence is a valid \trace up to entering $G_i = \tup{s,\vts,\pi}$. Let $E_i$ be $\tup{e, a, \vts', \sigma}$. We now define the valid values of $G_{i+1} = \tup{s', \vts', \pi'}$:
\begin{PPI}

\item If $E_i$ is a party (resp. oracle) \einst, then it must be \compatiblewith some party (resp. oracle) \erule $r$ of $s$ that is \enabled in $G_i$ such that $\eppartconstr{r}$ is \True at $\tup{\vts, \vts', \pi, \sigma}$.

\item If $E_i$ is a deadline \einst, then it must be \compatiblewith the unique\footnote{by the \udc} deadline \erule $r$ of $s$ that is enabled in $G_i$ such that $\deadfn{r}(\vts, \pi) = \vts'$. Moreover, $\sigma$ must be $\psetter{r}(t,\pi)$.

\item $\pi' = \statetransform{e}(\vts, \vts', \pi, \sigma)$.

\end{PPI}
Any \wfeseq where $G_i, E_i$ satisfy the above requirements for all $i$ is a valid \anchorfor{\trace}{trace} for $M$.

\subsection{Reducing the Abstraction By One Level}
So far, \lsm is far from a {\it formal language} in that it does not have anything like an abstract syntax tree with finitely-many node categories. This is \underline{intentional}. In particular, we specified that certain components are mathematical {\it functions} or {\it relations}, rather than expressions that define such functions or relations. To recap, those components are as follows, where now we turn to the common convention of writing the types of relations as functions to \Bool.
\smallskip

\noindent {\bf Initial abstract components of \lsm \label{initialabstract}}:
\begin{LPPI}
\item $\statetransform{e} : \timestamp^2 \times \svsorts \times \eppartsorts{e} \rarr \svsorts$ for each \ename $e$.
\item $\reguard{r} : \timestamp \times \svsorts \rarr \Bool$ for each \erule $r$.
\item For each party or oracle \erule $r$ that \governs an \ename $e$:
	\begin{LPPI}
	\item $\eppartconstr{r} : \timestamp^2 \times \svsorts \times \eppartsorts{e} \rarr \Bool$
	\end{LPPI}
\item For each deadline \erule $r$ that \governs an \ename $e$.
	 \begin{LPPI}
	\item $\deadfn{r} : \timestamp \times \svsorts \rarr \timestamp$
	\item $\psetter{r} : \timestamp \times \svsorts \rarr \eppartsorts{e}$
	\end{LPPI}
\end{LPPI}

Despite the lack of concreteness, we saw that there is enough detail that execution can be defined precisely. We {\it could} stop there, but that would mean leaving out of the coming sections some useful details of formal verification routines that are very likely to be needed in any \lsm-compatible DSL.

In this section, we reduce the {\it description} of the abstraction level significantly, while maintaining the flexibility of being able to define \lsm-compatible languages that range from finite state machines to Turing complete languages.\footnote{Technically, \extlink{https://en.wikipedia.org/wiki/Turing_degree}{beyond Turing complete languages}, but we don't know of any practical uses of such languages!} We do not go as far as to define a language; that will happen in Section \ref{minlang}.


Recall that the set of basic datatypes or {\it sorts} \DT is a parameter to \lsm. After this section, we will have a notion of {\it class of \lsm} that depends only on \DT and a set \cF of functions on the sorts in \DT; that is, each function in such a set \cF is of type $S_1 \times \cdots \times S_k \rarr S_0$ for some $k \geq 0$ and some  $S_0,\ldots,S_k \in \DT$.
\begin{defn}[\anchorfor{\cFstar}{cFstar}]
Take \cFstar to be the closure of \cF under well-typed composition, with the normal meaning. So, it is the superset of \cF that contains functions such as the following function of type $S_1 \times S_2 \rarr S_1$:
\[a_1{\in}S_1, a_2{\in}S_2\ \mapsto f_1(a_1, f_2(a_2))\]
where $f_1,f_2 \in \cF$ and $f_2$ has type $S_2 \rarr S_1$ and $f_1$ has type $S_1 \times S_1 \rarr S_1$.
\end{defn}
\noindent Note that, for the sake of this report, we take individual elements of the sorts $\DT$ to be $0$-ary functions in $\cFstar$; doing so simply reduces the description length of some definitions.

Surprisingly little is needed in the way of additional definitions. Assume $\timestamp \in \DT$.\footnote{Technically this implies that an extra constraint will be needed to define finite-state machines: roughly, that no \statevars of type \timestamp are allowed, and the functions in \cF cannot depend on their \timestamp arguments, even if \timestamp appears in the function type.}  Since $\svsorts \in \DT^*$ already, the functions $\reguard{r}$, $\eppartconstr{r}$, and $\deadfn{r}$ are already elements of $\cFstar$ (which is what we want). The remaining two categories of functions in the bullet-list above, $\psetter{r}$ and $\statetransform{e}$, simply get replaced by their point-wise components:
\begin{LPPI}
\item For each deadline \erule $r$ that \governs an \ename $e$, and each event parameter $\eppart{i}{e}$ of sort $S_i \in \eppartsorts{e}$, a function $\anchorfor{\psetterpart{r}{i}}{psetterpart} :  \timestamp \times \svsorts \rarr S_i$ from $\cFstar$.\footnote{Or we will sometimes write $\psetterpart{r}{\eppart{i}{e}}$ when it helps more than clutters.}
\item For each \ename $e$, and each sort $S_i \in \svsorts$, a function $\anchorfor{\stranspart{e}{i}}{stranspart} : \timestamp^2 \times \svsorts \times \eppartsorts{e} \rarr S_i$ from $\cFstar$.
\end{LPPI}

We go one step further by introducing some minimal structure into the
$\statetransforms$, which has a role in \textcolor{blue}{\hyperref[symbexec]{symbolic execution}}.
\begin{defn}[\anchorfor{\statement}{statement}, \anchorfor{\stransimpl}{stransimpl}]
For $\ename$ $e$, an \anchorfor{\estatement{e}}{estatement} is one of:
\begin{PPI}
\item $\assign{q}{f}$ for some $q \in \statevars$ of sort $S$\footnote{i.e. $\svsorts(x) = S$} and some function $f$ of type $\timestamp^2 \times \svsorts \times \eppartsorts{e} \rarr S$ in $\cFstar$.
\item $\cond{f}{U_1}{U_2}$ for some function $f$ of type $\timestamp^2 \times \svsorts \times \eppartsorts{e} \rarr \Bool$ in $\cFstar$ and finite sets of \estatements{e} $U_1, U_2$.
\end{PPI}
A \stransimpl of $\statetransform{e}$ is a set of \estatements{e} that satisfies the\\
 \anchorfor{\uuc}{uuc}, which says: Consider the rooted tree formed by the set of \estatements{e} \statetransform{e}\footnote{The tree: A set of \estatements{e} is an internal node whose children are the individual \statements, with the top-level set $\statetransform{e}$ itself being the root of the tree. An assignment $\assign{x}{f}$ is a leaf node. A conditional $\cond{f}{U_1}{U_2}$ is a second kind of internal node with two children $U_1$ and $U_2$ (which, observe, are themselves internal nodes of the first kind).}. Any well-typed setting of the \statetransform{e} parameters yields a value of \True or \False in the ``test'' part $f$ of each conditional node $\cond{f}{U_1}{U_2}$. Consider the subtree formed by dropping the appropriate ``branch'' $U_1$ (if test is \False) or $U_2$ (if test is \True) of each such node, at every level. Then any \statevar may occur at most once in that subtree.
\end{defn}

We now officially modify the specification of \lsm to say that each \statetransform{e} is a \stransimpl, instead of being a set of functions of types $\{ \timestamp^2 \times \svsorts \times \eppartsorts{e} \rarr \svsorts(q) \ | \ q \in \statevars \}$).

\begin{bnote}
We will give a specific elaboration of the definition of execution from Section \ref{execution} soon, but you can probably infer it already. Just note that our use of sets of \statements instead of lists of \statements is intentional; their order doesn't matter.
\end{bnote}

\subsection{Basic Specification: \lsmclass{\cF}}
Since the start of Section \ref{lsmdef}, we've elaborated some details of the initial definition of \lsm, to bring it closer to being a useful subject for formal verification. Here we give just the concise final specification, without explanation of the semantics.

\medskip

Let $\DT$ be a set of sorts (i.e. datatypes, i.e. sets). Let $\cF$ be a set of functions each of type $S_1 \times \cdots \times S_k \rarr S_0$ for some $k \geq 0$ and some $S_0,\ldots,S_k \in \DT$. Then $\cF$ determines a class of \lsms that we denote $\lsmclass{\cF}$, which are defined below. For notational simplicity, and to reduce redundancy, we assume that every sort in $\DT$ is in the type of some function in $\cF$, so that we may uniquely determine $\DT$ from $\cF$. Let \anchorfor{$\sortsof{\cF}$}{sortsof} be that unique determination. We also assume $\timestamp \in \DT$.

Backpeddling on ``without explanation of the semantics'' for a moment: Note/recall that when a function in the following definition has a type starting with $\timestamp^2$, it is ``expecting'' the \timestamp of the most recent \einst followed by the \timestamp of a candidate next \einst. When the type starts with just $\timestamp$, the function is expecting just the \timestamp of the most recent \einst.

%
%Definition is on
%\pagebreak

\begin{defn}[\anchorfor{\lsmclass{\cF}}{lsmclass}]
Let $\DT$ be $\sortsof{\cF}$. An $\lsmclass{\cF}$ model is given by the following components.
\begin{LPPI}
\item $\timeunit$ in $\{\text{days, hours, minutes, seconds, \ldots}\}$.
\item Finite sets $\actor, \ename, \sname$, and $\statevar$.
\item A mapping $\svsorts$ from $\statevar$ to \DT.
\item For each $e \in \ename$, a (possibly empty) type for its parameters $\eppartsorts{e} \in \DT^*$.
\item For each $e \in \ename$, a \stransimpl $\statetransform{e}$, which is a set of $\estatements{e}$ that satisfies the \uuc. The functions used on the right side of assignment statements are from $\cFstar$.
\item A finite set $\erule$, with two partitions:
\begin{PPI}
\item \anchorfor{\prules}{prules}, \anchorfor{\orules}{orules}, and \anchorfor{\drules}{drules}
\item $\{ \shandlerof{s} \subseteq \erule \ | \ s \in \sname \}$ where each $\shandlerof{s}$ satisfies the \\ \udc.
\end{PPI}
\item An $\cFstar$ function $\reguard{r} : \timestamp \times \svsorts \rarr \Bool$ for each \erule $r$.
\item For each party or oracle \erule $r$ that \governs an \ename $e$:
\begin{PPI}
\item An $\cFstar$-function $\eppartconstr{r} : \timestamp^2 \times \svsorts \times \eppartsorts{e} \rarr \Bool$
\end{PPI}
\item For each deadline \erule $r$ that \governs an \ename $e$.
	 \begin{PPI}
	\item An $\cFstar$-function $\deadfn{r} : \timestamp \times \svsorts \rarr \timestamp$
	\item For each $r$-parameter $x_i$ of sort $S_i \in \eppartsorts{e}$, an $\cFstar$-function $\psetterpart{r}{i} :  \timestamp \times \svsorts \rarr S_i$
	\end{PPI}
%\item For each \ename $e$, and each sort $S_i \in \svsorts$, a function $(\stranspart{e}{i})^M : \timestamp^2 \times \svsorts^M \times \eppartsorts{e}^M \rarr S_i$.
\end{LPPI}
\end{defn}

\subsection{\lsmclass{\cF} Execution}
We only need to expand the line
\[ \pi' = \statetransform{e}(\vts, \vts', \pi, \sigma) \]
from Section \ref{execution}, but for the sake of a useful reference, we repeat the entire (short) definition here.

Fix a $M$ in $\lsmclass{\cF}$. Let $\tau = E_1, E_2, \dots$ be a \wfeseq of $M$. The starting \state $G_0$ is always $\tup{\startsname, 0, \initvals}$. Let $i \geq 0$ be arbitrary. Assume the sequence is a valid trace up to entering $G_i = \tup{s,\vts,\pi}$. Let $E_i$ be $\tup{e, a, \vts', \sigma}$. We now define the valid values of $G_{i+1} = \tup{s', \vts', \pi'}$:
\begin{PPI}

\item If $E_i$ is a party (resp. oracle) \einst, then it must be \compatiblewith some party (resp. oracle) \erule $r$ of $s$ that is \enabled in $G_i$ such that $\eppartconstr{r}$ is \True at $\tup{\vts, \vts', \pi, \sigma}$.

\item If $E_i$ is a deadline \einst, then it must be \compatiblewith the unique\footnote{by the \udc} deadline \erule $r$ of $s$ that is enabled in $G_i$ such that $\deadfn{r}(\vts, \pi) = \vts'$. Moreover, $\sigma$ must be $\psetter{r}(\vts,\pi)$.

\item $\pi' = \statetransform{e}(\vts, \vts', \pi, \sigma)$. The evaluation of $\statetransform{e}$, and in general of any set of $\estatements{e}$ $U$, $\anchorfor{\statementsetexec(U,\vts,\vts',\pi,\sigma)}{statementsetexec}$, works as follows.
	\begin{PPI}
	\item If $U$ contains a conditional $e$ of the form \statement $\cond{f}{U_1}{U_2}$, let $b$ be the truth value $f(\vts,\vts',\pi,\sigma)$. If $b$ is \True then
	\[\statementsetexec(U,\vts,\vts',\pi,\sigma) = \statementsetexec(U - e \cup U_1,\vts,\vts',\pi,\sigma) \]
	else if $b$ is \False then
	\[\statementsetexec(U,\vts,\vts',\pi,\sigma) = \statementsetexec(U - e \cup U_2,\vts,\vts',\pi,\sigma) \]
	\item if $U$ contains no conditional \statement, then let $q_1 \larr f_1, \ldots, q_k \larr f_k$ be its contents. So $\{q_1,\ldots,q_k\}$ is a subset of \statevar and $\{f_1,\ldots,f_k\}$ is a subset of $\cFstar$. Then $\pi'$ is identical to $\pi$ except at $q_i$, where
	\[ \pi'(q_i) = f_i(\vts,\vts',\pi,\sigma) \]

	\end{PPI}

\end{PPI}
Any \wfeseq where $G_i, E_i$ satisfy the above requirements for all $i$ is a valid \trace for $M$.












\section{Automated Formal Verification for \lsm} \label{lsmstatic}

\subsection{Satisfiability Modulo Theories (SMT) Technology}
%We use SMT prover tech extensively, but might help.
Familiarity with SMT is not a prerequisite for this document, but if you are unfamiliar and interested, Microsoft's \extlink{https://rise4fun.com/z3/tutorial}{Z3 tutorial} is a fine place to start.

\subsection{Checking the Basic Correctness Conditions}
We will define here how we use an SMT prover to verify the \udc, \nsc, and \uuc.

\subsection{\lsmclass{\cF} Extension: Adding Pre/Postconditions and Invariants}

\subsection{Symbolic Execution} \label{symbexec}
In model checking for expressive models (say, with at least nonlinear integer arithmetic available), usually\footnote{The term ``model checking'' seems to be used rather inconsistently, at least in the computational law literature.} an infinite-state model is approximated by a finite or tamely-infinite state model, and correctness properties of the approximation model are checked exhaustively, or exhaustively up to a certain maximum computation path length. In Section \ref{tamelyinfinite} we will consider some cases where approximation is not necessary.

Symbolic execution is a technique for avoiding some of the approximation, especially for avoiding having to approximate unbounded datatypes with bounded ones (e.g. $\RR$ approximated by {\sf float}). We do not do this for the sake of more accurate/faithful correctness theorems. Indeed, most of the time software is executed with bounded numeric datatypes anyway, and even when not, no fixed computer can actually compute with arbitrarily large numbers. Rather, we use symbolic execution because, if there is not actually complex math going on (e.g. any cryptographic functions) in a program, but only the use of functions that puts us outside decidable theories, then we should be able to save a lot of time by analyzing computation paths in axiomatically-defined batches.

\subsubsection{Initial values, fixed or not?}

First, observe that due to the nondeterminacy in the occurrence of \einsts (which recall can have parameters), using fixed \initvals is not like using fixed inputs in formal verification of software (which would then just be testing, unless the software interacts with an environment, in which case the situation is similar to ours). 
%That being said, \lsm/L4 does not require fixed initial values of its \statevars. 
When we symbolically execute an \lsm, we have a choice about whether to use some, all, or none of the model's \initvals of its \statevars. Generally, the more of them used, the faster \statespace exploration will be. For example, in a loan agreement we could treat an interest rate as an arbitrary element of $(0,1)$. We would then be proving correctness of the agreement for interests rates that we'll never use, which of course is perfectly fine if the analysis finishes in a reasonable amount of time. Alternatively, we could use fixed values of the interest rate only, and whenever we use a new fixed interest rate (for a new instance of the contract), we simply rerun symbolic execution.



%\pagebreak
\subsubsection{Timeless Normal Form for $\lsmclass{\cF}$}
We define a normal form for $\lsmclass{\cF}$ which is not literally ``timeless'', but removes the special significance of \timestamp from the model. This is just to make the symbolic execution algorithm simpler.

First, and unrelated to the following \timestamp-related transformations (but with the same goal of simplifying symbolic execution), we eliminate $\reguard{r}$ for each party/oracle \erule $r$, as described in Note \ref{guardredundancy}. Next:
\begin{LPPI}
\item Introduce a new \statevar $\tlast$ of sort \timestamp with initial value $0$. The new versions of $\svsorts, \initvals, \statevar$ are the same as the old but with the additions: $\svsorts'(\tlast) = \timestamp$ and $\initvals'(\tlast) = 0$ and $\statevar' = \statevar + \tlast$.
\item Add a parameter $\tnext$ of sort \timestamp to every \ename.\footnote{i.e. $\eppartsorts{e}(\tnext) = \timestamp$ for every \ename $e$.}
\item Add $\assign{\tlast}{\tnext}$ to $\statetransform{e}$ for each $e$.
\item For each deadline \erule $r$:
\begin{LPPI}
	\item For existing event parameters $x$ (i.e. not \tnext), $\psetterpart{r}{x}$ does not change, since its domain type $\timestamp \times \svsorts$ is already equivalent to $\svsorts'$.  
	\item Define $\psetterpart{r}{\tnext}(\vx) := \deadfn{r}(\tnext, \vx)$.
\end{LPPI}	
\item Add $>_{ts} {:} \timestamp \times \timestamp \rarr \Bool$ to $\cF$.
\item Conjoin $\tnext >_{ts} \tlast$ to $\eppartconstr{r}$ for each party/oracle \erule $r$.
\end{LPPI}
Those transformations take us to the following slightly simplified \lsmclass{\cF} definition:
\begin{defn}[\anchorfor{\timelesslsmclass{\cF}}{timeless-lsmclass}]
Let $\DT$ be $\sortsof{\cF}$. The relation $>_{ts} {:} \timestamp \times \timestamp \rarr \Bool$ must be in $\cF$ (and so \timestamp must be in \DT). A $\timelesslsmclass{\cF}$ model is given by the following components.
\begin{LPPI}
\item $\timeunit$ in $\{\text{days, hours, minutes, seconds, \ldots}\}$.
\item Finite sets $\actor, \ename, \sname$, and $\statevar$.
\item A mapping $\svsorts$ from $\statevar$ to \DT.
\item For each $e \in \ename$, types for its parameters $\eppartsorts{e} \in \DT^*$.
\item For each $e \in \ename$ a \stransimpl, $\statetransform{e}$, which is a set of $\estatements{e}$ that satisfies the \uuc. The functions used on the right side of assignment statements are from $\cFstar$.
%\item For each $s \in \sname$ a \shandler, $\shandlerof{s}$, which is a subset of $\erule$ that satisfies the \udc.
\item A finite set $\erule$, with two partitions:
\begin{PPI}
\item \prules, \orules, and \drules
\item $\{ \shandlerof{s} \subseteq \erule \ | \ s \in \sname \}$ where each $\shandlerof{s}$ satisfies the \\ \udc.
\end{PPI}
\item For each party or oracle \erule $r$ that \governs an \ename $e$
    	\begin{PPI}
	\item An $\cFstar$-function $\eppartconstr{r} : \svsorts \times \eppartsorts{e} \rarr \Bool$
	\end{PPI}
\item For each deadline \erule $r$ that \governs an \ename $e$.
	\begin{PPI}
	\item An $\cFstar$ function $\reguard{r} :  \svsorts \rarr \Bool$ for each \erule $r$.
	\item For each sort $S_i \in \eppartsorts{e}$, an $\cFstar$-function $\psetterpart{e}{i} :  \svsorts \rarr S_i$
	\end{PPI}
\end{LPPI}

\end{defn}



\subsubsection{A Minimal \timelesslsmclass{\cF}-Compatible Language} \label{minlang}


Here we define a language (syntax) for \timelesslsmclass{\cF} that is {\it just enough} to exhibit the symbolic execution algorithm in Section \ref{sealg} in a style that is typical of research in programming languages. It is not strictly speaking {\it necessary} to introduce such a syntax, but it is probably simpler.

\medskip

\noindent Introduce source language symbols, each with a dedicated sort in \DT (as per Note \ref{nameconvention}):
\begin{PPI}
\item \anchorfor{\sv{i}}{sv} for the $i$-th \statevar.
\item \anchorfor{\eppart{i}{e}}{eppart} for the $i$-th parameter of \ename $e$.
\item \anchorfor{\eparams{e}}{eparams} for the tuple of $e$'s parameters.
%\item $\rp{i}{r}$ to stand for the $i$-th parameter of \erule $r$.
\end{PPI}

We previously used the metavariable $f$ for elements of $\cF$ or $\cFstar$. We now use it also for elements of a set of function symbols, \anchorfor{\ffnsymb}{ffnsymb}, where there is one such symbol for each element of $\cF$. Each $f \in \ffnsymb$ inherits the function type of the corresponding function in $\cF$, but in a (perhaps misguided) effort to not obscure meaning, we don't introduce notation for that, nor for the sorts of $\sv{i}$ and $\eppart{i}{e}$. This extends Note \ref{nameconvention} to function symbols.

The following definitions of \srcfterm and \smtfterm are essentially just complete term languages for $\cFstar$, but differing in the symbols they use for variables.

\begin{defn}[\anchorfor{\srcfterm}{srcfterm} and their types]
The set \srcfterm, and the type of an $\srcfterm$, are defined by:
\begin{PPI}
\item Every \statevar $\sv{i}$ and event parameter $\eppart{i}{e}$ is in \srcfterm. The type of each is of course its dedicated sort.
\item If $t_1,\ldots,t_k \in \srcfterm$ and have types $S_1,\ldots,S_k \in \DT$ and $f \in \ffnsymb$ of type $S_1 \times \cdots \times S_k \rarr S_0$, then $f(t_1,\ldots,t_k) \in \srcfterm$ and has type $S_0$.
\end{PPI}
\end{defn}

We introduce a set \anchorfor{\smtvar}{smtvar},  containing a countable set of variable names for each sort in \DT. These are the existential variables that the SMT prover will try to solve for.

\begin{defn}[\anchorfor{\smtfterm}{smtfterm} and their types]
The set \smtfterm, and the type of an $\smtfterm$, are defined by:
\begin{PPI}
\item Every \smtvar is in \smtfterm. An \smtvar's type is of course its dedicated sort.
\item Same as in the \srcfterm defn.\\ If $t_1,\ldots,t_k \in \smtfterm$ and have types $S_1,\ldots,S_k \in \DT$ and $f \in \ffnsymb$ of type $S_1 \times \cdots \times S_k \rarr S_0$, then $f(t_1,\ldots,t_k) \in \smtfterm$ and has type $S_0$.
\end{PPI}
\end{defn}

\todomin{This is not finished! Still need to introduce the syntax for event rules, for example.}





\subsubsection{Symbolic Execution for \timelesslsmclass{\cF}} \label{sealg}


\noindent {\bf Metavariables used in the algorithm:}
\begin{PPI}
\item $e,s,r$ range over $\ename, \sname, \erule$, respectively.
\item $v$ ranges over \smtvars.
\item $P$ ranges over \smtfterms of type \Bool. It is usually called a ``path constraint'' in symbolic execution algorithms.
\item $\psi$ ranges over \srcfterms of type \Bool. $t$ ranges over \srcfterms in general.
\item $U$ ranges over sets of $\estatements{e}$ (all elements share the same $e$).
\item $\svtosmt$ ranges over certain $\statevar$-substitutions, namely over full mappings from $\statevar$ to \smtfterms of the correct type.
\item Define \anchorfor{\esubst{e}}{esubst} to be the set of mappings from $\eparams{e}$ to \smtfterms of the correct type. Then \\
$\eptosmt$ ranges over $\bigcup_{e \in \ename} \esubst{e} $
\end{PPI}


%The algorithm is defined on a triples $(\Gamma, P, \gamma)$, where $\gamma$ is one of:
%\begin{PPI}
%\item A finite set of $\estatements{e}$.
%\end{PPI}
We define two ``judgements,'' both written with $\vdash$, but differing in the number of arguments they take. Together they define a many-output function, whose return values (\rv below) are whatever information about the symbolic path taken that you wish to collect. Let $\anchorfor{\serv}{serv}$ be the type of that information.
\begin{PPI}
\item $\svtosmt; P \vdash \yields{\bterm{thing}}{\rv}$ is defined for \bterm{thing} a \sname, \shandler, or an \erule.
\item $\eptosmt; \svtosmt; P \vdash \yields{\bterm{thing}}{\rv}$ is defined for \bterm{thing} a set of \statements. Recall that an $\ehandler$ is a set of \statements.
\end{PPI}
$\serv$ should include:
\begin{PPI}
\item The set of \snames visited, the set of \enames and \erules used, and the set of \statements evaluated, if you want to use symbolic execution to compute code coverage.
\item The number of times each \statevar is ``written to'' in an assignment \statement, if you want to check write count bounds given in the source code (not a part of \lsm, but a feature in L4).
\item The entire \trace, if you are using symbolic execution to debug your contract, or if you are using it to speed up the process of writing test cases.
\item The \trace length, if you want to check bounds on that given in the source code.
\end{PPI}
Let \anchorfor{$\info{\cdot,\cdot,\cdot}$}{info} be your function for extracting the $\serv$ from the data you have at the end of a consistent symbolic execution path (currently $\svtosmt, P, s$). We will generalize that later, most importantly for extracting information from consistent (reachable) execution paths that contain errors (e.g. failed assertions, which we haven't added to the model yet).

\begin{defn}[\anchorfor{\cF-consistent}{consistent}, i.e. \anchorfor{\cF-satisfiable}{satisfiable}]
Let $\cLofF$ be the many-sorted first order language with a sort symbol for each set in $\sortsof{\cF}$ and a function symbol for each function in $\cF$. The types of the function symbols are of course the types of the corresponding functions. Let $T_\cF$ denote the first order theory of $\cLofF$ interpreted by $\cF$. We say that an $\cLofF$-formula $B$ is \cF-consistent (or \cF-satisfiable) if there is a well-typed assignment of objects from $\bigcup \DT$ to the free variables of $B$ that makes the formula true according to some model of $T_\cF$.\footnote{Some SMTLib theories have more than one standard model due to how undefinedness is handled, or due to the allowance of uninterpreted function symbols.}
\end{defn}


\bigskip

\noindent Now it is time for the proof.sty part. :-)

\medskip

\noindent Every \sname other than those in \termin has a non-empty \shandler:
\[
\infer{\svtosmt ; P \vdash \yields{ s }{\info{\svtosmt, P, s}}}
{s \in \termin}
%
\qquad
%
\infer{\svtosmt ; P \vdash \yields{ s }{\rv}}
{ s \not\in \termin
&
\svtosmt ; P \vdash \yields{ \shandlerof{s} }{\rv}}
\]


% situations and situation handlers
\noindent From a \shandler (which recall is just a set of \erules), each \erule is tried:
\[
\infer{
	\svtosmt ; P \vdash \yields{ \shandlerof{s} }{\rv}
}
{
	r \in \shandlerof{s}
&	\svtosmt; P  \vdash \yields{r}{\rv}
}
\]
%
% actor rule
In the following rule for party/oracle \erules, the as-yet not-explicitly-defined $fresh$ is an impure function that, given the ordered set of some \ename $e$'s parameters (which recall by Note \ref{nameconvention} have globally assigned sorts), returns an \esubst{e} mapping them to fresh (not used before) \smtvars of the corresponding sorts.
\[
\infer{
	\svtosmt ; P \vdash \yields{ \actorrule{R}{e}{ \psi }} {\rv}
}
{	\stackone
		{P' = P \wedge \psi[\eptosmt, \svtosmt]}
		{\eptosmt \leftarrow fresh(x^e)}
& 	\isconsistent{P'}
&	\eptosmt; \svtosmt; P'  \vdash \yields{\ehandlerof{e}}{\rv}
}
\]

% deadline rule
\[
\infer{
	\svtosmt ; P \vdash \yields{ \deadrule{e}{\psetterpart{e}{1},\ldots,\psetterpart{e}{k}}{\psi}}{\rv}
}
{
P' = P \wedge \psi[\svtosmt]
& \isconsistent{P'}
&	\stackone{\eptosmt; \svtosmt; P' \vdash \yields{\ehandlerof{e}}{\rv} }
			{\sigma = \eparams{e} \mapsto \psetterpart{e}{1},\ldots,\psetterpart{e}{k}}
}
\]

% statements
\noindent A conditional \estatement{e} results in following one or two paths via the following two rules.
\[
\infer{
	\eptosmt ; \svtosmt ; P \vdash \yields{ U \cup \{ \cond{\psi}{X_1}{X_2} \} }{\rv}
}
{
	P' = P \wedge \psi[\eptosmt, \svtosmt]
&	\isconsistent{P'}
& 	\eptosmt; \svtosmt; P' \vdash \yields{U \cup X_1}{\rv}
}
\]
\[
\infer{
	\eptosmt; \svtosmt ; P \vdash \yields{ U \cup \{ \cond{\psi}{X_1}{X_2} \}}{\rv}
}{
	P' = P \wedge (\neg\psi)[\eptosmt, \svtosmt]
&	\isconsistent{P'}
& 	\eptosmt; \svtosmt; P' \vdash \yields{U \cup X_2}{\rv}
}
\]

The algorithm arrives at the need to use the following rule after repeated use of the two $\cond{\cdot}{\cdot}{\cdot}$ rules.
\noindent {\bf Note:} There is currently no rule for single assignment statements $\assign{q_i}{t}$ because we have omitted the obvious-but-tedious definition of the ``updated by'' function used in the following rule.
\[
\infer{
	\eptosmt; \svtosmt ; P \vdash \yields{   \{ \assign{q_{i_1}}{t_{i_1}}, \ldots, \assign{q_{i_m}}{t_{i_m}}  \}   }{\rv}
}{	\stackone
	 	{\eptosmt; \svtosmt' ; P \vdash \yields{\edest{e}}{\rv} }
		{\svtosmt' = \svtosmt \text{ updated by } \{ \assign{q_{i_1}}{t_{i_1}[\eptosmt,\svtosmt]}, \ldots, \assign{q_{i_m}}{t_{i_m}[\eptosmt,\svtosmt]}  \}}
}\]


%Because symbolic execution can be used both to search for bugs and to exhaustively check a (sometimes infinite) state space, and which task one is doing determines how one should resolve nondeterminism choices. On the other hand, there are parts of the algorithm that should always proceed deterministically. For this reason, we adopt two styles of defining the algorithm.
%For simplicity, we will give here a symbolic execution algorithm without some simple optimizations that we have implemented. Most notably, we will introduce new constants whenever it's convenient to do so.


\subsection{Exhaustive Model Checking for Finite and Tamely-Infinite State Spaces} \label{tamelyinfinite}
The main topic of this section will be a reduction to a Timed Automata model checking problem for a restricted class of \lsmclass{\cF}, but we will begin with the even more restricted class whose model checking problem is equivalent to model checking finite automata.

\subsubsection{Finite Automata / Buchi Automata} \label{finiteautomata}

Suppose the only \statevars in an \lsm $M$ are typed with small finite sorts such as \Bool or enums,\footnote{Technically the following is true for {\it any} finite sorts, but then the representation as a finite state machine becomes prohibitively expensive.} and suppose that for every \erule $r$ and \ename $e$ none of $\reguard{r}$, $\deadfn{r}$, $\eppartconstr{r}$, $\statetransform{e}$, or $\psetter{r}$ depend on their \timestamp arguments. Then $M$ is equivalent for formal verification purposes to a kind of compressed\footnote{via the boolean \statevars} deterministic finite state machine (FSM), or when infinite \traces are allowed, to a compressed Buchi Automaton. Let's consider the general case where infinite \traces are allowed. Then any properties expressible in the logic \extlink{https://www.cs.toronto.edu/~wehr/buchis_theorem_relating_finite_automata_on_streams_and_S1S.pdf}{S1S}, which includes safety and liveness properties, are decidable about $M$.

Since most legal contracts involve time at least a little, and since model checking for the more-general Timed Automata model is also tractable, we will skip giving the reduction for this special case in favour of the one given in the next section.

\subsubsection{Timed Automata} \label{timedautomata}
We may relax the constraint from the previous section on the functions/predicates that take \timestamp arguments somewhat, allowing constraints that are boolean combinations of atomic formulas of the form \[ \text{(linear fn of $t$,$t'$)} \ (\leq | < | =) \ \text{(linear fn of $t$,$t'$)} \] where $t$ is the current \timestamp and $t'$ is the next. DateTime and TimeDelta literals can be used also, in the higher-level DSL, by compiling them down to expressions about \timestamps. What we arrive at is a computation model that is close or equivalent to \extlink{https://drum.lib.umd.edu/bitstream/handle/1903/15232/Fontana_umd_0117E_15027.pdf?sequence=1&isAllowed=y}{Timed Automata} with two clocks, one of which is never reset (for the time since the start of the contract) and the other that is reset after each \einst.




\subsection{Unbounded-Trace Formal Verification with Pre/Post\-conditions and Invariants}

\todomin{WARNING: This section is very hastily written.}

We use SMT provers (possibly falling back to general first-order theorem provers in cases where the SMT prover gives up) in a second way, distinct from symbolic execution. Consider that almost all of the computation in an \lsm happens in the \statetransforms. We may avoid symbolic execution's limitation to bounded traces by employing preconditions (including the already-available \reguard{r} and \eppartconstr{r}) and postconditions in various places. The tradeoff is that we lose a certain completeness property of symbolic execution; it never never considers behaviours that cannot occur in real executions. In contrast, in the approach of this section, we prove stronger properties about components of the contract (individual \statetransforms, especially) than are actually needed for correctness. At this point, we're overdue for an example.


\subsection{Unexplored: Hard Unbounded-Trace Formal Verification with Interactive Theorem Proving}

\section{Extensions}
\subsection{Uninitialized \texorpdfstring{\statevars}{State Variables}}
It is very common in computational contracts, and programming in general, to have state variables that are not meaningful until they are written to the first time, and then are meaningful forever after. L4 introduces a significant extension of the minimal type system that \lsms have (see Section \ref{typechecking}), which allows one to introduce an {\tt Option} or {\tt Maybe} type operator. However, it is wrong and inconvenient to treat an uninitialized {\tt T} variable as type {\tt Maybe T} if it never becomes {\tt None} again after first getting a value of the form {\tt Some x}. 

We therefore propose an extension to $\lsmclass{\cF}$ where $\initvals$ can omit some $\statevars$. This requires an additional correctness condition to be checked using the methods of Section \ref{lsmstatic}:\\
\anchorfor{\noreadbeforewrite}{noreadbeforewrite} - If \statevar $q$ is omitted from $\initvals$, then there is no computation path in which it is read before it is written. 





\subsection{Unbounded \texorpdfstring{\actor}{actor} Set}
This is to accommodate smart contracts (aka dapps). It is a \textbf{\underline{very}} tentative proposal.

\newcommand{\unknown}{\term{unknown}}
\newcommand{\role}{\term{role}}
We introduce to the definition of \lsmclass{\cF} another finite set \anchorfor{\role}{role}, which always include a special symbol \anchorfor{\unknown}{unknown}. \unknown is the role of a party (i.e. ethereum address, in the ethereum dapp context) who has never interacted with the contract before, and who was not known to the parties who initiated the contract. It is thus used at most once by any one party. An \einst allowed by an \erule governing \unknown has the side effect of assigning a non-\unknown \role to the party that initiates the \einst.

\section{L4: An Experimental but Practical \lsm-compatible DSL}
\subsection{The Largest Set of Examples}
We follow, more seriously than any similar project, the tenant that DSL development should be guided by usage.

%\extlink{}{}
%\subsection{Syntax is Not Important}

\subsection{Type Checking with Subtyping and Intersection Types} \label{typechecking}


\section{Related Work}

This is thoroughly covered by \extlink{https://github.com/legalese/complaw-deeptech/blob/master/doc/chapter-201707.org}{Meng's book chapter} and Appendix B of the \\ \extlink{https://conferences.law.stanford.edu/compkworking201709/wp-content/uploads/sites/40/2017/07/WhitePaperDraftfordistroApril32018.pdf}{CodeX whitepaper} {\it Developing a Legal Specification Protocol: Technological Considerations and Requirements.}


\section{\texorpdfstring{\todomin{Dustin's todo}}{Dustin's todo}}
\subsection{ASAP}
Before it's done, absence of these could make some sections of the text unnecessarily hard to read.
\begin{LPPI}
\item \todomin{How to read} - this should be priority 1...
\item \todomin{A brief defn of substitution for Section \ref{sealg}.}
% done \item \todomin{A note in Section \ref{sealg} that $P \text{ consistent}$ is the result of an SMT query.}
\end{LPPI}

\subsection{Priority}
Before it's done, leaves undocumented some progress we've made.
\begin{LPPI}
\item Add \todomin{assertions, invariants, preconditions, postconditions}. These are super useful when combined with symbolic execution.
\item L4 section, obviously.
\end{LPPI}

\subsection{Low Priority / Questionable}
\begin{LPPI}
\item \todomin{Consider changing } $\timestamp^2 \times \svsorts \times \eppartsorts{e} \rarr \svsorts$ to
\[ (\timestamp \times \svsorts) \times (\timestamp \times \eppartsorts{e}) \rarr \svsorts \]
since it better reflects the ``Timeless'' reduction.
% NO, because they're needed for expressing the types of things: \item \todomin{Kill $\eppartsorts{e}$ and $\svsorts$ in favour of the one-sort-per-name requirement?}
\item \todomin{Backlinks into ``Metavariables used in the algorithm''}
\item \todomin{Eliminate the word ``sort'' and replace with ``atomic type''?}
\end{LPPI}


\end{document}
