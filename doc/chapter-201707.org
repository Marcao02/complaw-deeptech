#+TITLE: Computable Contracts: from Academia to Industry
#+AUTHOR: mengwong@legalese.com

pre-publication, not for redistribution ([2017-07-28 Fri])

* Outline

- i will talk about the three generations of smart contract templates,
- survey the current initiatives,
- catalog the prior art in computable contracts,
- motivate expressive DSLs in the third generation, from a security perspective and a verifiability perspective, (Oxford commas)
- raise the complementarity between smart contracts and smart statutes, and
- close with a couple of science fiction quotes, for which the publisher may need to seek copyright permission.


* Introduction

Ever since Ethereum was conceived in 2013, critics have quipped: "Smart contracts are neither smart nor contracts".

Four years later, computer scientists are responding: "Challenge accepted."

For context, this paper surveys the past and present of computational law. The history of software suggests a future for law: legacy formats and traditional jurisprudence are on a collision course with trustless blockchains and opensource legal engineering.

What industry initiatives are afoot in the world of blockchain smart contracts? From what wells of academia do they draw inspiration? What insights from computer science could transfer to the world of legal reasoning and drafting? If tomorrow's consumers of legal services turn first to self-help apps and chatbots, before resorting to human "tech support", will the practices of tomorrow's lawyers look more like those of software engineers?

* Two Traditions

This paper was written at the end of July 2017. It was an exciting month: in the span of three short weeks, five separate initiatives were announced, all with the same stated goal: to bridge the brave new world of blockchain "smart contracts" with the ancient traditions of law.

What does that mean? It means surrounding the automated execution of on-chain Ethereum bytecode with the exception-handling mechanisms of real-world dispute resolution. It means translating written rituals of offer and agreement, employing stylized phrases dating back centuries, into the cold, clean semantics of formal logic.

This paper labels this family of initiatives "smart contract templates", or SCTs.

SCTs represent a marriage between two noble families, each proud with history, but rooted in different cultures.

* Contract Templates

The first, and older, tradition is that of the lawyer: the legal draftsman, the scribe, the notary. This is the tradition also of the handbook of model forms, of the clause bank of contract templates, of copy-and-paste and fill-in-the-blanks.

Model templates reflect the mundane fact that commercial relationships run to a finite set of genres: the rental or sale of assets; the borrowing and lending of money; equity investment and divestment; a fee for services, as contractor or employee. Just as brides and grooms around the world recite the words "in sickness and in health, for richer or for poorer, till death do us part", business everywhere happily reuse the same sets of stock phrases to memorialize their relationships. In 2016 a contract carved in stone was unearthed in a Dionysian temple on the Anatolian coast: it was a student rental, in which tenants would be penalized for damages and were required to provide guarantors. It was 2,200 years old.[fn:teos]

Most contract templates are coarse-grained: they fill in the blanks at the level of the document. If customizations need to be made then different document templates need to be constructed. There is often significant textual overlap between such templates. Y Combinator, for example, provides a template for an investment agreement called a SAFE. SAFEs can be configured with or without a valuation cap, and with or without a discount rate: two configurables, hence four variants. Accordingly, Y Combinator's web site offers four Word documents for download. If it had three configurables, there would be eight variants; four configurables, sixteen.

** First-Generation Document Assembly

This exponential increase presents an obvious opportunity for software smarts: composable clause libraries and conditional logic. In the 1980s and 1990s, the advent of desktop publishing led to the first wave of document assembly, or document automation, systems -- DAs for short. DAs helped automate business processes: salespeople could quickly generate their own agreements from templates previously blessed by legal.

DAs had much in common with the venerable mail merge: the key operation was "fill in the blanks", the key object the template, and the key logic "how do we compose templates together?" The key output: a natural language document typically intended for signature by both parties. DA systems offer an attractive combination of business-user-friendliness and software flexibility. In the 1980s, early A.I. -- expert systems and decision trees -- organized templates and guided end-users through the process of filling in the blanks.

In the legal domain, first-generation DA systems include HotDocs, ContractExpress, and Exari. Most of these systems were developed in the 1990s and 2000s as proprietary enterprise software, serving law firms and big companies.

** Ricardian Contracts

"Fill in the blanks" leads to the idea of recording data values in a database, separate from their templates. Digitization leads to the idea that a contract could enjoy a purely paperless existence from start to finish. These ideas were connected by Ian Grigg in the form of the "Ricardian contract": a template paired with a data structure to fill it, but kept separate until the last possible moment, like an epoxy superglue. The data structure follows some standard format, what an XML purist would call a DTD schema. The template matching a schema could be a natural-language document intended for humans -- or a program intended for computers. Finally the document would be given legal effect by some kind of digital signature, linked cryptographically to the identities of the parties.

** Second-Generation Smart Contract Template systems

Second-generation DA systems, which this paper will call SCT2 systems, continue this tradition into the 2010s. They tend toward opensource and Web technologies like Javascript. CommonAccord and CommonForm are examples of the opensource generation of smart contract templates). Many of these SCT2 systems also look toward blockchain-level operations.

** (Smart) (Contract Templates)

The above tradition, descending for law and spanning two generations of software, interprets the term "Smart Contract Templates" as contract templates that are, in some sense, smart.

But that is not the only tradition, and not the only interpretation. There is another tradition with a different interpretation.

* Smart Contracts

In the early 1990s, Nick Szabo proposed "smart contracts"[fn:szabo1994]: agreements that were not just digital and machine-readable, but also formalized and machine-executable. Not mere PDFs or XMLs, but /programs/, describing the obligations of the parties and the rules of their interaction in code that a computer could interpret and reason over.

Such a contract would be suitable for automated execution. One example: a vending machine[fn:szabo1997], simple enough to be described as a deterministic finite automaton, or DFA. Another example: a financial futures contract[fn:szabo2002], also simple enough to be described as a DFA[fn:goodenough]. DFAs, and their cousin the Petri Net[fn:lee1988], have an interesting and useful property: they are amenable to a powerful formal verification technique called model checking, which employs a special engine called a SAT solver.

** Formal Verification with Model Checking

Think of a SAT solver as a black box with two inputs. On one hand, like Paul Muad'dib swallowing Water of Life to enter a clairvoyant trance[fn:herbert1965], a SAT solver swallows a program and prepares to contemplate every possible future envisaged by the code.

On the other hand, a SAT solver accepts a specification, in which you assert certain safety or liveness properties that you believe the contract should respect -- in other words, a specific prophecy. Specialized logics called LTL and CTL[fn:CTL] are used to incant these prophecies.

Given these inputs, the SAT solver looks across all possible futures in search of a /counterexample/, in which -- depending on how you asked the question -- either the prophecy is fulfilled, or the prophecy fails. Computer scientists call this "model checking". It is akin to what computers do when they play checkers or chess: they peer into the future in search of a specific scenario.

In 1994, the FDIV bug[fn:fdiv] cost Intel over $400 million in recalls, and galvanized the field of model checking. Ever since, hardware engineers -- microchip designers -- have employed model checking to prove that their designs will work correctly when fabbed to silicon. In the immensely competitive, billion-dollar business of CPU manufacturing, errors are simply unacceptable.

Since 1994, multiple mature software packages[fn:SMTLIB] have been developed to be capable of this work.

What does this have to do with contracts? Business contracts can be worth billions of dollars. Mistakes in contracts can also cost millions, as lawsuits over the Oxford comma have demonstrated (in Canada in 2006[fn:comma2006], and in the US in 2017[fn:comma2017]).

** Model Checking Contracts

Yet the legal field has nothing like the testing tools that programmers enjoy. Programmers have developed an extensive arsenal in their war on bugs. Formal verification is just one tool; others include unit testing, linting, fuzzing, and static type checking.

Darmstadter 2010[fn:darmstadter] compared contract drafting with software engineering:

#+BEGIN_QUOTE
But compared to the testing engineers and programmers do, the testing of legal documents is hopelessly backward. Essentially, someone drafts the document and other people read it. If they notice problems, they alert the draftsman, who makes some changes. That's it. 
#+END_QUOTE

Given the similarities between the fields, it was only a matter of time before somebody tried applying formal verification to contracts. Model checking of contracts was first demonstrated in 2006 by Pace, Prisacariu, and Schneider.[fn:pps2006] (See also [[https://theses.ncl.ac.uk/dspace/handle/10443/1814][Abdelsadiq]] 2013.) Model checking of legislation was demonstrated by Fernando Schapachnik et al in 2011[fn:formalex2011].

As the term suggests, formal verification requires a contract to first be formalized: translated into a logical notation for which an explicit, unambiguous formal semantics has been defined.[fn:floyd1967] In other words, into a program, written in some programming language specialized for law.

** Formal Languages for Law

Financial contracts were the first to be formalized. Special-purpose contract languages have been developed, along Ricardian lines, within the limited domain of financial agreements: examples include [[https://en.wikipedia.org/wiki/FpML][FpML]] (1999) and Lexifi's [[https://www.lexifi.com/product/technology/contract-description-language][MLFi]] (2000).

Subsequently, more general-purpose languages for contract formalization have been developed in academia. The most relevant:

- CL (Contract Language) by Pace and Schneider was the subject of John Camilleri's 2016 thesis work[fn:anacon];
- CSL (Contract Specification Language) was the subject of Tom Hvitved's 2013 PhD thesis;
- FormaLex by Schapachnik has been ongoing from 2011 to 2017.

These languages typically borrow from modal logic:
- deontics define the obligations and prohibitions of parties;
- temporal logics describe events and [[http://dl.acm.org/citation.cfm?id=940106][fluents]] in time;
- epistemic logics (approximately, CCS, CSP, and process calculi) formalize the sending and receiving of notices among parties.

Contract languages also borrow from rule logics. Reaction rules (the if/then constructs that are the mainstay of imperative programming languages) forward-chain from facts to conclusions. Deliberation, or deduction, rules (typically structured as Horn clauses in logic programming languages) backward-chain from consequent to antecedent. The RuleML standard emerged from work on the Semantic Web, and is being specialized for law in the form of LegalRuleML.

Rules may conflict. Defeasible logics[fn:governatori] help resolve these conflicts using exceptions, priorities, and meta-rules.

This tradition of academic research evolved slowly and steadily, elaborating Szabo's original vision for "smart contracts". The term seemed apt to describe a born-digital contract which took shape first as a program in a text editor. That program might later compile to a Word document or a PDF, but such projections were only shadows cast upon a cave wall by the Platonic ideal of the smart contract code.

Then, in the 2010s, a handful of billionaire anarchists co-opted the term "smart contract" and gave it a new meaning.

** Enter Blockchain

While one corner of academia toiled away at contract formalization and verification, another obscure corner of cypherpunk crypto-anarchists were fomenting a revolution that would change the world. In their hands, cryptography 1.0 (which concerned itself with message encryption and endpoint authentication) was reborn as cryptography 2.0, which repurposed hashes for proof-of-work, and repurposed public keys to sign irrevocable ledgers.

Bitcoin launched in 2011. Ethereum launched in 2015. Since then the market cap of those and other cryptocurrencies has risen, collectively, to over $80B.

These blockchain technologies provided the missing element of Szabo's original vision: a tamper-proof, globally accessible cryptographic ledger on which the "world computer" -- the Ethereum virtual machine -- could be built; and on that EVM, contracts could be run.

These programs, amenable to automated, trustless execution, were labeled "smart contracts". And, sure as night follows the day, smart contracts turned out to be just as fallible any other program: they had bugs.[fn:survey]

In fintech, bugs are security vulnerabilities; attackers are highly motivated; and exploits cost money. Entire wallets can be drained. Millions can be lost.

The first major attack on an Ethereum smart contract happened in June 2016, when TheDAO began draining due to a bug in the Ethereum smart contract. In its wake came calls for better security.

Security is a multi-pronged challenge with no silver bullet. Techniques include audits[fn:zeppelin]; language-based security[fn:langsec]; and formal verification[fn:fvsc]. But security is always easier said than done: in July 2017 the Parity multisig bug hit.[fn:parity]

Whereas traditional law represents centuries of accumulated experience with disputes of all kinds, the first generation of cryptocurrencies deliberately excluded dispute resolution as being inconsistent with the decentralization ethos. As a consequence, you can't have a lawsuit in Ethereum; you can only have a constitutional crisis.

The hard-fork which followed the TheDAO incident amounted to a central intervention in an obstensibly decentralized cryptocurrency. This event highlighted the need for a more robust governance model.[fn:primavera2016]

Partly in response to Ethereum's perceived security failings[fn:survey], and partly in response to Ethereum's perceived governance failings, Tezos launched. Tezos containd two innovations. First, a new smart contract blockchain and language (called Michelson) based on a stack-based virtual machine, suitable for formal verification. Second, a promise of more democratic distributd governance: essentially, a "by the people, for the people, of the people" for the blockchain generation. They raised the largest ICO in history: over $200M.

** (Smart Contract) (Templates)

All of these smart contract initiatives have one thing in common.

Most commercial agreements fall into a small number of known genres. Most software programs can be classified into a small number of categories. It stands to reason that smart contracts -- which are both commercial agreements and software artefacts -- will also end up organized by genre.

Two software dynamics will then drive the evolution of smart contract software.

First, mature software engineers prefer not to write software, if at all possible; rather than reinvent the wheel, they would much rather reuse a tried-and-tested library. A library and a template have much in common: they are reusable, customizable, standard components.

Second, the technical difficulty of developing secure software libraries will drive down the number of widely-respected, generally accepted alternatives.

So the result will be a relatively small number of smart contract libraries which have both passed rigorous formal verification, and been widely adopted. These libraries will be the smart-contract world's answer to the idea of a model form contract template.

From this perspective, SCTs are templates for smart contracts: (smart contract) (templates).

* Smart-Contract Templates meet Smart Contract-Templates

In the legal tradition, where computerization has brought smarts to contract templates, SCT means (smart) (contract templates).

In the software tradition, research into contract formalization and the crypto 2.0 rise of blockchain smart contracts mean that SCT stands for (smart contract) (templates).

In July 2017, these traditions finally met, like Montagues and Capulets colliding.

In yet another example of multiple discovery, five matchmakers came almost simultaneously to the conclusion that it was time for Romeo to kiss Juliet.

This paper follows the lead set by R3, in which the term "Smart Contract Templates" is meant to invoke a sense of integrating across both traditions, both interpretations.

* An Industry Snapshot of SCT2.5 Bridges

The matchmakers envision a bridge between smart contracts and natural language contracts. Libraries of contract templates will emerge, with a foot in both worlds. Once the blanks are filled in, the contracts will take shape both as Ethereum smart contracts and as PDF or docx paperwork suitable for parties to sign.

This paper calls such dual-use smart contract templates "Generation 2.5 SCT" systems, or SCT2.5 for short.

In July 2017 alone, five new SCT2.5 systems were announced. All are in development and none are widely used at time of writing.

| Initiative    | Announced    | (S)(CT) | (SC)(T) | Backed by    | Opensource | Maturity      | Consortium             | Funds Raised |
|---------------+--------------+---------+---------+--------------+------------+---------------+------------------------+--------------|
| [[http://www.commonaccord.org/][CommonAccord]]  | 2001         | (S)(CT) |         | James Hazard | github     | running code  |                        |              |
| [[https://commonform.org/][CommonForm]]    | 2015         | (S)(CT) |         | Ironclad     | github     | in use        |                        | $120k        |
| [[https://www.r3.com/press/SCT3-press-release.pdf][R3]]            | 2016         |         | (SC)(T) | Barclays     | ?          | consortium    | banks, law firms       | $107M        |
| [[http://internetofagreements.com/][Mattereum]]     | [[https://www.reddit.com/r/ethereum/comments/6lvfuu/mattereum_legally_enforceable_smart_contracts/?st=j4uhqi6b&sh=fb6aaa85][7 July 2017]]  | (S)(CT) | (SC)(T) | Hexayurt     | ?          | white paper   |                        |              |
| [[https://www.agrello.org/][Agrello]]       | [[https://blog.agrello.org/the-agrello-token-sale-has-begun-bd10a2ea71b9][16 July 2017]] |         | (SC)(T) | Estonians    | ?          | ICO           |                        | $15M ICO     |
| [[http://openlaw.io/][OpenLaw.io]]    | [[https://media.consensys.net/introducing-openlaw-7a2ea410138b][25 July 2017]] | (S)(CT) | (SC)(T) | Consensys    | claimed    | demo          |                        |              |
| [[http://accordproject.org/][AccordProject]] | [[https://medium.com/@accordhq/the-accord-project-launches-industry-first-tools-and-standards-for-smart-legal-contracts-with-2e67b2b6f2fd][26 July 2017]] | (S)(CT) | (SC)(T) | Hyperledger  | claimed    | press release | clause.io, clio, IACCM |              |
| [[https://blog.zeppelin.solutions/introducing-zeppelinos-the-operating-system-for-smart-contract-applications-82b042514aa8][ZeppelinOS]]    | [[https://blog.zeppelin.solutions/introducing-zeppelinos-the-operating-system-for-smart-contract-applications-82b042514aa8][27 July 2017]] |         | (SC)(T) |              |            | press release |                        |              |

* Strengths of 1st and 2nd generation systems

DA and SCT2 systems are sufficient to solve several classes of problems.

To get multilingual contracts, simply extend the singular template into a list of concrete languages: the same values can fill multiple blanks.

When circumstances demand customization, refactor the templates at the appropriate level of granularity and extend the logic to compose accordingly, based on decision variables in the code.

Customization is a function of expressiveness: the more expressive the system, the easier it is to customize.

* Weaknesses of 1st and 2nd generation systems

DA and SCT2 approaches face two major limitations.

** Syntax versus Semantics

The semantics of a contract reside in natural language. The advent of cryptocurrencies brings an increasing demand for integration between natural language and blockchain-native smart contracts. However, DA systems are limited to filling static values into static blanks. They can fill names and numbers and strings, and they may be able to switch sub-templates based on Booleans and case expressions, but they do not offer a way to express the logical semantics of the contract itself.

** Expressiveness

What if an end-user legal developer wants to customize a contract template?

| Before                                              | After                                   |
|-----------------------------------------------------+-----------------------------------------|
| The Buyer will pay the Seller a fixed fee of $1000. | The Buyer will pay the Seller a fee of: |
|                                                     | - if the moon is full: $1200            |
|                                                     | - else, if the tide is high: $1400      |
|                                                     | - otherwise: $800                       |

Most programming environments offer a standard set of conveniences: mathematical expressions, if/then/else logic, lambda functions, and function calls. None of these are expressible in the original design of the Ricardian contract.

A computer scientist would say that, at best, the notion of a Ricardian contract, which has its roots in templates and database tables, lacks a rich expression language; at worst, it lacks first-class functions.

** Specialized Knowledge

Just as database design and administration tends to end up the specialty of the DBA, customization of contract templates requires specialized knowledge which tends to accumulate in the department of the "contract template admin". It would be better for this capability to be distributed throughout the organization, along the lines of the computer literacy movement that says everyone should be able to code.

** Internationalization

In Model-View-Controller lingo, 1st and 2nd generation DA/SCT systems tend to intermingle the presentation view with the business logic of the data model. There are no clean boundary layer separations: a single template may contain chunks of hardcoded text, output formatting instructions, data blanks, and logical directives to show/hide.

Such a structure is unclean. What if you want not just one language but a multilingual family of templates? If all the functionality initially lives in a single template file, copying the template file to a different language means duplicating the logic. Changing the logic means visiting all the templates. Extending a new blank field to the template family means editing all the templates. This is not i18n/L10n best practice, nor is it MVC best practice.

* 3rd generation smart contract templates

To overcome these limitations, some have proposed to take the Ricardian contract to the next level: to encode not just the data values but the full logical semantics of a contract.

3rd generation SCT systems (SCT3), as described by [[http://contractcode.io/][contractcode.io]] and [[http://compk.stanford.edu/][compk.stanford.edu]], solve many of these problems. Harry Surden has written extensively on [[http://lawreview.law.ucdavis.edu/issues/46/2/articles/46-2_surden.pdf][Computable Contracts]], describing the possibilities of 3rd generation systems and anticipating the challenges of deeply integrating expressive code with the legacy legal system.

In an SCT3 system, a domain-specific programming language (DSL) is provided to express the logical semantics of a contract. The DSL goes beyond key/value Ricardian template filling, and begins to resemble a Turing-complete programming language. (For esoteric reasons, it is likely that an SCT3 system will stop short of Turing-completeness, trading off expressive power for decidability and provability.)

The toolchain for that DSL operates in multiple stages.

** Opensource Templates
We assume that, as with a 2nd gen SCT, a library of 3rd gen templates are available in some opensource repository, easily imported by a program, the way NPM has made Node modules easy to import. As with Node modules, SCT3 templates could be sized at any level of functionality, from a sentence fragment (for Oxford commas) to a standard exemption clause to an entire contract workflow (such as a SAFE plus its sides).

We preserve the Ricardian notion of separating data from template, but the data itself can contain code: rich expressions that the toolchain knows how to reduce to natural language and smart contract primitives.

** Compiler Toolchain
Stage 1 (the lexer/parser) compiles programs written in that DSL into an intermediate form representing the contract in the abstract -- what one might recognize as being akin to a Gen 2 smart contract template, but highly structured and with semantics fully available for inspection and evaluation.

Stage 2 (the template filler) takes the output of Stage 1, adds the particulars of a contract instance (parties, configured terms and conditions, etc), and produces an abstract grammar, losslessly preserving all the semantics of the source template and data/expression values.

Stage 3 (natural language generator) is a computational linguistics system responsible for concretizing the abstract grammar from Stage 2 into one or more natural languages, at the highest possible degree of granularity: individual words and parts-of-speech, where possible, and with canned blocks of text otherwise.

Other stages may be connected up in parallel to this primary pipeline. For example, the compiler may delegate to an offboard static analyzer which performs compile-time bug-finding.

3rd gen systems enjoy a number of advantages over 1st and 2nd gen SCTs.

** What-If Scenario Exploration

An interactive interface could help the end-user game out scenarios they are concerned about, to see what the outcomes will be, without needing an expensive lawyer to talk them through the possibilities.

** Formal Verification

As discussed above, compatibility with formal verification means that it will be easy to use an FOL/SAT/SMT solver to verify safety and liveness properties over contract scenarios. See [[https://www.researchgate.net/publication/221027131_Model_Checking_Contracts_-_A_Case_Study][Model Checking Contracts]].

** Controlled Natural Language Generation

[[https://en.wikipedia.org/wiki/Natural_language_generation][Produce the natural language version]] of the contract from the ground up, using a tool such as [[http://www.grammaticalframework.org/][GF]].

** Multilingual Generation

With the right infrastructure, producing English, French, Spanish, Chinese contracts should be just a matter of checking a few boxes.

** Isomorphism with Diagrams

Produce visual flowcharts in a way that would make [[https://legalinformatics.wordpress.com/2014/02/23/passera-haapio-and-curtotti-making-the-meaning-of-contracts-visible-automating-contract-visualization/][Helena Haapio and Stefania Passera]] happy. [[https://en.wikipedia.org/wiki/Business_Process_Model_and_Notation][BPMN]] is a leading candidate for choice of notation.

** Isomorphism with Blockchain Smart Contracts

In the Ethereum domain, transpile to Solidity / Viper or compile to EVM.

Going beyond Ethereum, [[http://www.tezos.community/t/michelson-101/23][Tezos's Michelson language]] is another compilation target.

** Runtime Automated Execution

A convertible note, once signed, goes to sleep until the next funding round. It wakes up, reads the next-round contract (which is, naturally, also expressed as a 3rd gen program), and automatically produces all the paperwork needed for the conversion.

This is akin to the sort of automated execution promised by blockchain smart contracts, but could run equally well off the chain. Smart contracts can still be smart without blockchain.

* Connecting SC-Ts with S-CTs

Unification between blockchain smart contracts and legacy paper is the goal of several SCT2.5 systems. Their template orientation means that Gen 2.5 SCT systems will be able to bridge the gap, albeit crudely.

Gen 3 SCT systems, having been designed for the purpose from the ground up, will be able to bridge the gap elegantly, and offer the features listed above, which SCT2.5 systems will not.

* Why a DSL?

How are SCT systems evolving? The history of the Web is instructive.

One of the first technologies to make the Web interactive was the Server-Side Include[fn:ssi]: a crude templating system capable of stitching together individual HTML files.

Then came PHP, originally named "Personal Home Page / Forms Interpreter". The analogy with key/value-driven Gen 1 DA and Gen 2 SCT systems is unmistakable. Its author Rasmus Lerdorf said: "there was never any intent to write a programming language […] I have absolutely no idea how to write a programming language, I just kept adding the next logical step on the way." The PHP-era web could be described as being full of "Ricardian web pages", where templates are personalized by filling in the blanks to suit each user, in a structured document containing both text and data extracted from SQL databases by a server back-end and piped statically to the client's browser.

This is the organic evolutionary process that takes us to Gen 2.5 SCT today: feature after feature accreting in response to demand.

But the dominant paradigm on today's web is the web app powered by client-side Javascript. Single-page apps are enabled by the ability to run Turing-complete code in a sandbox, in user's browser. These apps are supported by an ecosystem of Javascript libraries easily remixed and reused by developers.

And that is where the third generation of SCT systems is headed.

** Legalese Seen As Object Code

(a version of the following text was originally published on Medium, on Jan 21 2017)

Every few years, the idea of a “Github for law” turns up on Hacker News.

https://news.ycombinator.com/item?id=13447059

It’s natural to think “contracts are just chunks of text; we should be able to throw them together easily. Skinny jeans, strappy sandals, a sweater: voilà, an outfit!”

A JSON-style key/value approach may make sense for a standalone lawyer producing first-cut documents, but those documents better be in Word format, because the other side will want to edit them, and you’re back to the original problem again.

And that problem stands in the way of building a Github for Law.

Legal documents that have been heavily edited often have the nature of a compiled object. Look at this example from Missouri:

#+BEGIN_QUOTE text
233.285.  Law not to affect road districts incorporated prior to effective date. — The repealing of the sections and law repealed by this law shall not have the effect of abating, nullifying, suspending or vitiating any public road district incorporated, or established by preliminary order, prior to the taking effect of this law or any proceedings by any such public road district; but any public road district finally incorporated, or established only by preliminary order, prior to the taking effect of this law, except districts established only by preliminary order in which there has been held a meeting of landowners of the district, in compliance with laws repealed by this law, at which owners of a majority of the acres of land in the district failed to vote in favor of the improvement of any road or roads proposed to be improved, shall, from and after the taking effect of this law, by the name mentioned in the preliminary order of the county commission establishing it, be a political subdivision of the state for governmental purposes with all the powers mentioned in sections 233.170 to 233.315 and such others as may from time to time be given by law, and shall, after the taking effect of sections 233.170 to 233.315, proceed, and shall have and exercise, and the commissioners and landowners and voters thereof shall have and exercise, the same privileges, powers and duties as if such district was incorporated after the taking effect of sections 233.170 to 233.315 and under and in accordance with sections 233.170 to 233.315; except that valid contracts made or entered into before the taking effect of sections 233.170 to 233.315, under laws hereby repealed, shall be complied with the same as if such laws were still in force; and except that any such district in which there has been a meeting of landowners of the district, in compliance with laws repealed by sections 233.170 to 233.315, at which owners of a majority of the acres of land in the district voted that any road or roads therein be improved and the cost thereof charged against the lands in the district, may proceed, and the commissioners thereof may proceed in making such improvement, and tax bills, or bonds may be issued and collected on account of such improvement, in the same manner as if the laws repealed by sections 233.170 to 233.315 were still in force and effect and sections 233.170 to 233.315 not yet in effect; but in case no contract for such improvement has been entered into, or tax bills or bonds issued by reason of such vote for such improvement, such district, and the commissioners and landowners thereof may, in making such improvement or issuing tax bills or bonds on account thereof, proceed as if such district had not been incorporated until after the taking effect of sections 233.170 to 233.315, and was incorporated under and in compliance with sections 233.170 to 233.315; or said special road district commissioners may file with the clerk of the county commission the tabulated statement or statements of the lands in the district as prepared previous to such meeting, and, if they have not done so already, make out and file with the clerk of the county commission a report of the action of the landowners at such meeting, signed and acknowledged by them, and the clerk of the county commission, after such report and tabulated statement are so filed, shall give notice, by at least two publications in some weekly newspaper published in the county, that said special road district commissioners have filed with him a report of an election in such district, and a tabulated statement of the lands in the district, showing the valuations fixed by them on each tract thereof for the purposes of an assessment for road improvement voted upon at such meeting, and such notice shall state a day not less than two weeks later than the date of the first publication of such notice, upon which the county commission will be in session and will hear and consider exceptions and objections to such report and tabulated statement and to the valuations so fixed on any or all tracts of land in the district, and the county commission shall, upon said day or as soon thereafter as the business of the county commission will permit, hear and consider any objections or exceptions that may be made to such report, and at such hearing such report shall be prima facie evidence of the statements therein made, and the county commission, if no objections or exceptions are made to such report, or if it find, after considering and hearing any objections that may be so made, and any evidence that may be offered, that such special road district commissioners prior to such meeting, and at such meeting, proceeded in compliance with the law then in force, and called such meeting and gave notice thereof in compliance with the law then in force, and that the action of the landowners at such meeting was as stated in such report, the county commission shall hear and consider such objections and exceptions as may be made to such tabulated statement or to valuations fixed on lands in the district as in such tabulated statement indicated, and, after hearing and considering such objections and exceptions, and such evidence as may be offered, shall make any alterations and corrections of said tabulated statement, and of the valuations so fixed and indicated, or fix such valuations on any of such lands, as it may deem proper, and shall thereupon approve such tabulated statement, and the valuations indicated therein, and order the clerk of the county commission to annex to said tabulated statement a certificate of such approval, and thereafter such district, and the special road district commissioners thereof, and the clerk of the county commission, in making such improvement and contracting for the same, or in issuing tax bills to pay for the same, or issuing bonds or tax bills to pay such bonds, may proceed as if this law had not taken effect, and the laws hereby repealed still in effect, except that the special road district commissioners need not make out and certify to the county clerk a description of the lands in the district as required by laws hereby repealed, and the county clerk in apportioning against each tract of land in the district its share of the cost of the improvement or its share of the principal and interest on the bonds, shall use, for the purpose of making such apportionment, such tabulated statement as so approved by the commission.
#+END_QUOTE

Does that remind you of something? The last time I felt this way was when I opened a binary executable in a hex editor. And that was a long, long time ago. Remember the 1980s? The era of proprietary software, before the Internet, when people shared programs on floppy disks. Not as source code, but as binaries. I remember turning on cheat codes by opening up .EXE files and twiddling specific address locations.

https://sites.google.com/site/kmbrandt/hexeditor.jpg

Binary code consists of machine instructions intended for CPUs. Editing raw binary is a dangerous thing; a single change in one spot often implies a cascade of changes throughout the rest of the file.

No wonder one of the very first inventions in computer science was the compiler. A programmer writes source code in a high level language to work out the solution to a software problem, function by function, module by module, the way a screenwriter writes a script to work out the plot of their story, line by line, scene by scene. Then the screenplay enters production and turns into a gigabyte of MPEG data; the source code enters a compiler and turns into ten megabytes of machine code. Every time the source code changes, the compiler rebuilds the binary.

In that sense, a contract template -- say, a Word document with yellow blanks -- is a special kind of machine binary. If you're an end-user you may fill in the assigned blanks, but don't touch anything else! Because you haven't been ordained -- you're not in the priesthood.

But the life cycle of many business contracts involves some degree of negotiation. Yes, some contracts are take-it-or-leave-it[fn:adhesion]. But most B2B contracts ping-pong back and forth several times before the parties commit to signature. That means lots of editing.

Today, that editing happens at the level of the compiled binary. It should happen at the level of source code.

What happens when your counterparty wants to add a new clause in the middle of your template blocks? You have to “recompile” -- update all the cross-references and adjust the clauses to match the change. And that's just at the surface level. What about deeper changes to the semantics? That is, after all, the point of negotiation. One change to the deal could entail half a dozen changes in the contract.

Where, then, is the source code for a business contract, for a piece of legislation? Largely in the heads of lawyers, it turns out. The closest thing to a high-level language version of a contract is a term sheet: a one-page version summarizing the configuration of the deal, which "definitive documentation" subsequently details.

Today, lawyers are human compilers, just as there used to be human computers. But we’ve seen this show before; we know what comes next. High-level languages. Reusable, modular libraries. Open source.

** Example: SCT2 versus SCT3

Let's look at an example of how SCT2 and SCT3 systems handle a common contract situation differently.

Suppose a startup investment agreement, such as a SAFE or a KISS, contemplates conversion to equity in some future round. To avoid premature conversion and dilution, the triggering round must be of a certain minimum size. So the language in a contract might be:

#+BEGIN_QUOTE text
Next Equity Financing means the next sale (or series of related sales) by the Company of its Preferred Stock following the Date of Issuance from which the Company receives gross proceeds of not less than MIN_PROCEEDS (excluding the aggregate amount of securities converted into Common or Preferred Stock in connection with such sale (or series of related sales)).
#+END_QUOTE

A 2nd generation SCT system might organize this template as follows:

#+BEGIN_SRC json
{ "template": "Next Equity Financing means the next sale (or series of related sales) by the Company of its Preferred Stock following the Date of Issuance from which the Company receives gross proceeds of not less than {{MIN_PROCEEDS}} (excluding the aggregate amount of securities converted into Common or Preferred Stock in connection with such sale (or series of related sales)).",
  "vars": {
    "MIN_PROCEEDS": "US$2,000,000",
  }
}
#+END_SRC

This is consistent with the original vision of the Ricardian Contract: a text template with an accompanying dictionary of key-value pairs.

Suppose, after negotiation, the parties agree to measure the size of the round in two ways instead of one. They revise the template:

#+BEGIN_SRC json
{ "template": "Next Equity Financing means the next sale (or series of related sales) by the Company of its Preferred Stock following the Date of Issuance from which the Company:--
- receives gross proceeds of not less than {{MIN_PROCEEDS}} (excluding the aggregate amount of securities converted into Common or Preferred Stock in connection with such sale (or series of related sales)); or
- is valued (prior to the sale (or series of related sales)) at no less than {{MIN_VALUATION}} (excluding the conversion of this instrument and other instruments of this type, and of convertible promissory notes).",
  "vars": {
    "MIN_PROCEEDS":   "US$2,000,000",
    "MIN_VALUATION": "US$10,000,000"
  }
}
#+END_SRC

This is good 2nd-generation work. How would this look in a 3rd-generation SCT?

#+BEGIN_SRC haskell
nef :: Definition FinancingRound = (en "Next Equity Financing")
    first [ round | round <- company.financingRounds
          , round.date after my.dateOfIssuance
          , round.instrument instanceof PreferredStock
          , ( round.proceeds > min_proceeds ||
              round.preMoneyValuation > min_valuation )
          ] where min_proceeds  = USD 2000000
                  min_valuation = USD 10000000
#+END_SRC

The template has become a program! The semantics have been formalized. The parties can now negotiate unambiguously about the meaning of the contract, trusting to the compiler to produce faithful language.

It is now the compiler's job to turn the program back into text. To do this, the compiler must know how to convert a wide range of possible expressions to natural language. This is a tractable problem and solutions have been demonstrated in the literature.

If further negotiation results in more changes to the program, no problem: changes to the text will follow automatically.

This approach is not possible in a 2nd-generation SCT system. It is only possible in a 3rd-generation system.

** Multiple Languages, Multiple Jurisdictions

Pushing the burden of natural-language generation to the compiler opens a number of doors.

Localizing a contract for a different jurisdiction, a different language, should be as simple as changing a single line in the file.

** Github for Law

The idea of "Github for Law" belongs more to the world of 3rd-generation SCT than 2nd-generation.

In the absence of SCT3 source code, a "Github for Law" is really a warez site, full of suspect, immutable binaries. PDFs are not source code. They’re the executable.

Going from SCT2 to SCT3 is fundamental stuff, which even the ancients would recognize as a giant step forward. The distinction between syntax, semantics, and pragmatics goes back two thousand years, to Publius Juventius Celsus:
SCIRE LEGES NON HOC EST VERBA EARUM TENERE SED VIM AC POTESTATEM
To know the law is not merely to understand the words, but as well their force and effect.
Justinian, Digest, Book 1, Title 3, 17

For the first time in history we can begin to move the not just the words, but the understanding of the words, and the understanding of their force and effect, into a machine.

* TODO the complementarity between smart contracts and smart statutes

So far we have been dealing with contracts. What about legislation and regulation? What about the law?

Contracts are private law. What about public law?

** Rule systems.

* TODO close with a couple of science fiction quotes, for which the publisher may need to seek copyright permission.

** accelerando

** golden age, john c. wright

* Footnotes

[fn:darmstadter] http://www.jstor.org/stable/25758526

[fn:formalex2011] http://publicaciones.dc.uba.ar/Publications/2011/GMS11/gms_flacos-2011-tr.pdf

[fn:pps2006] https://www.researchgate.net/publication/221027131_Model_Checking_Contracts_-_A_Case_Study

[fn:comma2006] https://www.theglobeandmail.com/report-on-business/comma-quirk-irks-rogers/article1101686/

[fn:comma2017] http://www.newyorker.com/culture/culture-desk/a-few-words-about-that-ten-million-dollar-serial-comma

[fn:floyd1967] https://classes.soe.ucsc.edu/cmps290g/Fall09/Papers/AssigningMeanings1967.pdf

[fn:anacon] https://gupea.ub.gu.se/bitstream/2077/40725/1/gupea_2077_40725_1.pdf

[fn:survey] https://eprint.iacr.org/2016/1007.pdf

[fn:zeppelin] https://openzeppelin.org/

[fn:langsec] https://en.wikipedia.org/wiki/Language-based_security

[fn:fvsc] http://dl.acm.org/citation.cfm?id=2993611

[fn:parity] http://hackingdistributed.com/2017/07/22/deep-dive-parity-bug/

[fn:primavera2016] https://policyreview.info/articles/analysis/invisible-politics-bitcoin-governance-crisis-decentralised-infrastructure

[fn:CTL] https://en.wikipedia.org/wiki/CTL*

[fn:SMTLIB] http://smtlib.cs.uiowa.edu/solvers.shtml

[fn:teos] http://www.haaretz.com/jewish/archaeology/1.746064

[fn:szabo1994] http://web.archive.org/web/20021016104429/http://www.firstmonday.dk:80/issues/issue2_9/szabo/index.html

[fn:goodenough] https://www.financialresearch.gov/working-papers/files/OFRwp-2015-04_Contract-as-Automaton-The-Computational-Representation-of-Financial-Agreements.pdf

[fn:szabo1997] http://www.fon.hum.uva.nl/rob/Courses/InformationInSpeech/CDROM/Literature/LOTwinterschool2006/szabo.best.vwh.net/idea.html

[fn:szabo2002] http://web.archive.org/web/20020806154414/http://szabo.best.vwh.net:80/contractlanguage.html

[fn:lee1988] https://www.researchgate.net/publication/228185635_A_Logic_Model_for_Electronic_Contracting

[fn:herbert1965] https://en.wikipedia.org/wiki/Dune_(novel)

[fn:fdiv] http://www.csl.sri.com/papers/computer96/computer96.html https://en.wikipedia.org/wiki/Pentium_FDIV_bug

[fn:governatori] http://www.governatori.net/research/pubs/index.html

[fn:ssi] https://en.wikipedia.org/wiki/Server_Side_Includes

[fn:adhesion] https://en.wikipedia.org/wiki/Standard_form_contract#Contracts_of_adhesion
